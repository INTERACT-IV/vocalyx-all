#!/bin/bash

# CLI Vocalyx - Outil en ligne de commande pour Vocalyx
# Usage: ./vocalyx_cli --action=transcribe <fichier_audio> <nom_projet> [options]

set -e

# Chemin du fichier de configuration
CONFIG_FILE="${HOME}/.vocalyx_config"

# Charger la configuration depuis le fichier si elle existe
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Configuration par d√©faut (apr√®s chargement du fichier de config)
API_URL="${VOCALYX_API_URL:-http://localhost:8000}"
USERNAME="${VOCALYX_USERNAME:-admin}"
PASSWORD="${VOCALYX_PASSWORD:-}"

# Couleurs pour les messages
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Fonction d'aide g√©n√©rale
show_help() {
    cat << EOF
Usage: $0 --action=<action> [arguments] [options]

Actions disponibles:
  transcribe    Cr√©er une transcription audio
  status        R√©cup√©rer le statut et le r√©sultat d'une transcription
  enrich        D√©clencher l'enrichissement d'une transcription
  purge         Supprimer des transcriptions selon des crit√®res

Options globales:
  -u, --username USERNAME    Nom d'utilisateur (d√©faut: admin ou depuis config)
  -p, --password PASSWORD    Mot de passe (ou depuis config)
  -a, --api-url URL          URL de l'API (d√©faut: http://localhost:8000)
  -h, --help                 Afficher cette aide

Variables d'environnement:
  VOCALYX_API_URL            URL de l'API Vocalyx
  VOCALYX_USERNAME           Nom d'utilisateur
  VOCALYX_PASSWORD            Mot de passe
  VOCALYX_PROJECT_API_KEY    Cl√© API du projet (si fournie, skip l'authentification)

Configuration:
  Le script peut lire les credentials depuis ~/.vocalyx_config:
    VOCALYX_USERNAME=admin
    VOCALYX_PASSWORD=mon_mot_de_passe
    VOCALYX_API_URL=http://localhost:8000

Pour l'aide sp√©cifique √† une action:
  $0 --action=transcribe --help
  $0 --action=status --help
  $0 --action=enrich --help
  $0 --action=purge --help
EOF
}

# Fonction d'aide pour l'action transcribe
show_transcribe_help() {
    cat << EOF
Action: transcribe

Cr√©er une transcription audio sur Vocalyx.

Usage: $0 --action=transcribe -f <fichier_audio> -P <nom_projet> [options]

Arguments requis:
  -f, --file FILE            Chemin vers le fichier audio √† transcrire
  -P, --project PROJECT      Nom du projet Vocalyx

Options sp√©cifiques √† transcribe:
  -m, --model MODEL          Mod√®le Whisper (tiny|base|small|medium|large-v3-turbo, d√©faut: small)
  --no-vad                   D√©sactiver VAD (Voice Activity Detection)
  --diarization              Activer la diarisation des locuteurs
  --enrichment               Activer l'enrichissement automatique apr√®s la transcription (prompts par d√©faut)
  --llm-model MODEL          Mod√®le LLM pour l'enrichissement (qwen2.5-7b-instruct|mistral-7b-instruct|phi-3-mini)
  --wait                     Attendre la fin de la transcription (et de l'enrichissement si activ√©) et afficher le r√©sultat (mode synchrone)
  -v, --verbose              Afficher les messages d√©taill√©s (par d√©faut: JSON uniquement)

Options globales:
  -u, --username USERNAME    Nom d'utilisateur (d√©faut: admin ou depuis config)
  -p, --password PASSWORD    Mot de passe (ou depuis config)
  -a, --api-url URL          URL de l'API (d√©faut: http://localhost:8000)

Exemples:
  $0 --action=transcribe -f audio.wav -P ISICOMTECH
  $0 --action=transcribe --file audio.mp3 --project MON_PROJET --model medium --diarization
  $0 --action=transcribe -f audio.wav -P ISICOMTECH --no-vad
  $0 --action=transcribe -f audio.wav -P ISICOMTECH --wait
  $0 --action=transcribe -f audio.wav -P ISICOMTECH --enrichment --wait
  $0 --action=transcribe -f audio.wav -P ISICOMTECH --enrichment --llm-model qwen2.5-7b-instruct --wait
EOF
}

# Fonction d'aide pour l'action status
show_status_help() {
    cat << EOF
Action: status

R√©cup√©rer le statut et le r√©sultat d'une transcription.

Usage: $0 --action=status -tid <transcription_id> [options]

Arguments requis:
  -tid, --transcription-id ID    ID de la transcription √† r√©cup√©rer

Options sp√©cifiques √† status:
  -v, --verbose              Afficher les messages d√©taill√©s (par d√©faut: JSON uniquement)

Options globales:
  -u, --username USERNAME    Nom d'utilisateur (d√©faut: admin ou depuis config)
  -p, --password PASSWORD    Mot de passe (ou depuis config)
  -a, --api-url URL          URL de l'API (d√©faut: http://localhost:8000)

Exemples:
  $0 --action=status -tid abc123-def456-ghi789
  $0 --action=status --transcription-id abc123-def456-ghi789
EOF
}

# Fonction d'aide pour l'action enrich
show_enrich_help() {
    cat << EOF
Action: enrich

D√©clencher l'enrichissement d'une transcription existante.

Usage: $0 --action=enrich -tid <transcription_id> [options]

Arguments requis:
  -tid, --transcription-id ID    ID de la transcription √† enrichir

Options sp√©cifiques √† enrich:
  -m, --llm-model MODEL         Mod√®le LLM (qwen2.5-7b-instruct|mistral-7b-instruct|phi-3-mini)
  --text-correction              Activer la correction du texte (orthographe, grammaire)
  --prompts-file FILE           Fichier JSON contenant les prompts personnalis√©s
  --wait                         Attendre la fin de l'enrichissement et afficher le r√©sultat (mode synchrone)
  -v, --verbose                 Afficher les messages d√©taill√©s (par d√©faut: JSON uniquement)

Options globales:
  -u, --username USERNAME    Nom d'utilisateur (d√©faut: admin ou depuis config)
  -p, --password PASSWORD    Mot de passe (ou depuis config)
  -a, --api-url URL          URL de l'API (d√©faut: http://localhost:8000)

Exemples:
  $0 --action=enrich -tid abc123-def456-ghi789
  $0 --action=enrich --transcription-id abc123 --llm-model qwen2.5-7b-instruct --text-correction
  $0 --action=enrich -tid abc123 -m phi-3-mini --prompts-file prompts.json
  $0 --action=enrich -tid abc123 --wait
EOF
}

# Fonction d'aide pour l'action purge
show_purge_help() {
    cat << EOF
Action: purge

Supprimer des transcriptions selon des crit√®res (fichiers audio inclus).

Usage: $0 --action=purge [options]

Options (au moins une requise):
  -tid, --transcription-id ID    ID de la transcription √† supprimer
  -P, --project PROJECT          Supprimer toutes les transcriptions d'un projet
  -d, --date DATE                Supprimer les transcriptions depuis cette date (format: YYYY-MM-DD ou YYYY-MM-DDTHH:MM:SS)
  --dry-run                      Afficher les transcriptions qui seraient supprim√©es sans les supprimer
  -v, --verbose                  Afficher les messages d√©taill√©s (par d√©faut: JSON uniquement)

Options globales:
  -u, --username USERNAME    Nom d'utilisateur (d√©faut: admin ou depuis config)
  -p, --password PASSWORD    Mot de passe (ou depuis config)
  -a, --api-url URL          URL de l'API (d√©faut: http://localhost:8000)

Exemples:
  $0 --action=purge -tid abc123-def456-ghi789
  $0 --action=purge -P ISICOMTECH
  $0 --action=purge -d 2024-01-01
  $0 --action=purge -P ISICOMTECH -d 2024-01-01
  $0 --action=purge -P ISICOMTECH --dry-run
EOF
}

# Charger la configuration depuis le fichier (fonction pour recharger si n√©cessaire)
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        # R√©initialiser les variables apr√®s rechargement
        API_URL="${VOCALYX_API_URL:-${API_URL:-http://localhost:8000}}"
        USERNAME="${VOCALYX_USERNAME:-${USERNAME:-admin}}"
        PASSWORD="${VOCALYX_PASSWORD:-${PASSWORD:-}}"
        # La cl√© interne peut √™tre d√©finie via INTERNAL_API_KEY ou VOCALYX_INTERNAL_KEY
        # Elle est export√©e pour √™tre accessible dans les fonctions
        export INTERNAL_API_KEY="${INTERNAL_API_KEY:-${VOCALYX_INTERNAL_KEY:-}}"
        echo -e "${BLUE}‚úì Configuration charg√©e depuis $CONFIG_FILE${NC}" >&2
    fi
}

# R√©cup√©rer la cl√© API du projet via JWT
get_project_api_key() {
    local username=$1
    local password=$2
    local api_url=$3
    local project_name=$4
    local verbose=${5:-false}
    
    # Obtenir le token JWT
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üîê Authentification...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${api_url}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${username}&password=${password}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Erreur d'authentification${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        return 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Impossible d'extraire le token${NC}" >&2
        fi
        return 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}‚úì Authentification r√©ussie${NC}" >&2
    fi
    
    # R√©cup√©rer les projets avec leurs cl√©s API
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üîç R√©cup√©ration de la cl√© API du projet '${project_name}'...${NC}" >&2
    fi
    local projects_response=$(curl -s -X GET "${api_url}/api/user/projects" \
        -H "Authorization: Bearer ${token}")
    
    # Extraire la cl√© API du projet
    local api_key=$(echo "$projects_response" | grep -o "\"name\":\"${project_name}\"[^}]*\"api_key\":\"[^\"]*" | grep -o '"api_key":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$api_key" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Projet '${project_name}' non trouv√© ou non accessible${NC}" >&2
            echo -e "${YELLOW}Projets disponibles:${NC}" >&2
            echo "$projects_response" | grep -o '"name":"[^"]*' | cut -d'"' -f4 | sed 's/^/  - /' >&2
        else
            echo "$projects_response" >&2
        fi
        return 1
    fi
    
    echo "$api_key"
}

# R√©cup√©rer la cl√© API du projet admin (utilis√©e comme cl√© interne pour DELETE)
get_admin_api_key() {
    local username=$1
    local password=$2
    local api_url=$3
    local verbose=${4:-false}
    
    # Obtenir le token JWT
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üîê Authentification...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${api_url}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${username}&password=${password}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Erreur d'authentification${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        return 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Impossible d'extraire le token${NC}" >&2
        fi
        return 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}‚úì Authentification r√©ussie${NC}" >&2
    fi
    
    # R√©cup√©rer la cl√© API du projet admin
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üîë R√©cup√©ration de la cl√© API du projet admin...${NC}" >&2
    fi
    local admin_response=$(curl -s -X GET "${api_url}/api/admin/admin-api-key" \
        -H "Authorization: Bearer ${token}")
    
    # Extraire la cl√© API du projet admin
    local admin_api_key=$(echo "$admin_response" | grep -o '"api_key":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$admin_api_key" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Impossible de r√©cup√©rer la cl√© API du projet admin${NC}" >&2
            echo "$admin_response" >&2
        else
            echo "$admin_response" >&2
        fi
        return 1
    fi
    
    echo "$admin_api_key"
}

# Fonction helper pour r√©cup√©rer le statut d'une transcription avec token JWT
get_transcription_status() {
    local transcription_id=$1
    local token=$2
    local api_url=$3
    
    local response=$(curl -s -X GET "${api_url}/api/user/transcriptions/${transcription_id}" \
        -H "Authorization: Bearer ${token}")
    
    if echo "$response" | grep -q '"id"'; then
        echo "$response"
        return 0
    else
        return 1
    fi
}

# Action transcribe
action_transcribe() {
    # Variables pour les options
    local audio_file=""
    local project_name=""
    local whisper_model="small"
    local use_vad="true"
    local diarization="false"
    local enrichment="false"
    local llm_model=""
    local verbose="false"
    local wait_for_completion="false"
    
    # Parser les arguments sp√©cifiques √† transcribe
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_transcribe_help
                exit 0
                ;;
            -f|--file)
                audio_file="$2"
                shift 2
                ;;
            -P|--project)
                project_name="$2"
                shift 2
                ;;
            -m|--model)
                whisper_model="$2"
                shift 2
                ;;
            --no-vad)
                use_vad="false"
                shift
                ;;
            --diarization)
                diarization="true"
                shift
                ;;
            --enrichment)
                enrichment="true"
                shift
                ;;
            --llm-model)
                llm_model="$2"
                shift 2
                ;;
            --wait)
                wait_for_completion="true"
                shift
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            -*)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Option inconnue: $1${NC}" >&2
                else
                    echo "{\"error\": \"Option inconnue: $1\"}" >&2
                fi
                show_transcribe_help
                exit 1
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Argument inattendu: $1${NC}" >&2
                    echo -e "${YELLOW}Utilisez -f/--file pour le fichier et -P/--project pour le projet${NC}" >&2
                else
                    echo "{\"error\": \"Argument inattendu: $1\"}" >&2
                fi
                show_transcribe_help
                exit 1
                ;;
        esac
    done
    
    # V√©rifier les arguments requis
    if [ -z "$audio_file" ] || [ -z "$project_name" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Arguments manquants${NC}" >&2
        else
            echo "{\"error\": \"Arguments manquants: fichier audio et projet requis\"}" >&2
        fi
        show_transcribe_help
        exit 1
    fi
    
    # V√©rifier que le fichier existe
    if [ ! -f "$audio_file" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Fichier audio introuvable: $audio_file${NC}" >&2
        else
            echo "{\"error\": \"Fichier audio introuvable: $audio_file\"}" >&2
        fi
        exit 1
    fi
    
    # Valider le mod√®le LLM si fourni
    if [ -n "$llm_model" ]; then
        case "$llm_model" in
            qwen2.5-7b-instruct|mistral-7b-instruct|phi-3-mini)
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Mod√®le LLM invalide: $llm_model${NC}" >&2
                    echo -e "${YELLOW}Mod√®les valides: qwen2.5-7b-instruct, mistral-7b-instruct, phi-3-mini${NC}" >&2
                else
                    echo "{\"error\": \"Mod√®le LLM invalide: $llm_model\"}" >&2
                fi
                exit 1
                ;;
        esac
    fi
    
    # Demander le mot de passe si non fourni
    if [ -z "$PASSWORD" ]; then
        if [ "$verbose" = "true" ]; then
            echo -n "Mot de passe pour $USERNAME: "
        fi
        read -s PASSWORD
        if [ "$verbose" = "true" ]; then
            echo ""
        fi
    fi
    
    # R√©cup√©rer la cl√© API (ou utiliser celle fournie en variable d'environnement)
    local api_key="${VOCALYX_PROJECT_API_KEY}"
    
    if [ -z "$api_key" ]; then
        api_key=$(get_project_api_key "$USERNAME" "$PASSWORD" "$API_URL" "$project_name" "$verbose")
        if [ $? -ne 0 ]; then
            exit 1
        fi
    else
        if [ "$verbose" = "true" ]; then
            echo -e "${GREEN}‚úì Utilisation de la cl√© API fournie${NC}" >&2
        fi
    fi
    
    # Cr√©er la transcription
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üì§ Envoi du fichier audio...${NC}" >&2
        echo -e "   Fichier: $audio_file" >&2
        echo -e "   Projet: $project_name" >&2
        echo -e "   Mod√®le: $whisper_model" >&2
        if [ "$enrichment" = "true" ]; then
            echo -e "   Enrichissement: activ√©" >&2
            if [ -n "$llm_model" ]; then
                echo -e "   Mod√®le LLM: $llm_model" >&2
            fi
        fi
    fi
    
    # Construire la requ√™te curl avec les param√®tres
    local response
    if [ -n "$llm_model" ]; then
        response=$(curl -s -X POST "${API_URL}/api/transcriptions" \
            -H "X-API-Key: ${api_key}" \
            -F "file=@${audio_file}" \
            -F "project_name=${project_name}" \
            -F "whisper_model=${whisper_model}" \
            -F "use_vad=${use_vad}" \
            -F "diarization=${diarization}" \
            -F "enrichment=${enrichment}" \
            -F "llm_model=${llm_model}")
    else
        response=$(curl -s -X POST "${API_URL}/api/transcriptions" \
            -H "X-API-Key: ${api_key}" \
            -F "file=@${audio_file}" \
            -F "project_name=${project_name}" \
            -F "whisper_model=${whisper_model}" \
            -F "use_vad=${use_vad}" \
            -F "diarization=${diarization}" \
            -F "enrichment=${enrichment}")
    fi
    
    # V√©rifier la r√©ponse
    if echo "$response" | grep -q '"id"'; then
        local transcription_id=$(echo "$response" | grep -o '"id":"[^"]*' | cut -d'"' -f4)
        local initial_status=$(echo "$response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        
        # Si --wait n'est pas activ√©, afficher le JSON et sortir
        if [ "$wait_for_completion" != "true" ]; then
            # Toujours afficher le JSON
            if command -v jq &> /dev/null; then
                echo "$response" | jq '.'
            else
                echo "$response"
            fi
            
            # Afficher les messages verbeux si demand√©
            if [ "$verbose" = "true" ]; then
                echo "" >&2
                echo -e "${GREEN}‚úì Transcription cr√©√©e avec succ√®s!${NC}" >&2
                echo "ID de transcription: $transcription_id" >&2
                echo "Statut: $initial_status" >&2
                echo "" >&2
                echo "Pour suivre la progression:" >&2
                echo "  $0 --action=status -tid ${transcription_id}" >&2
                echo "" >&2
                echo "Ou visitez le dashboard:" >&2
                echo "  ${API_URL%:8000}:8080" >&2
            fi
        else
            # Mode --wait : attendre la fin de la transcription
            if [ "$verbose" = "true" ]; then
                echo -e "${BLUE}‚è≥ Attente de la fin de la transcription...${NC}" >&2
                echo "ID: $transcription_id" >&2
                echo "Statut initial: $initial_status" >&2
            fi
            
            # Obtenir un token JWT pour le polling
            local token_response=$(curl -s -X POST "${API_URL}/api/auth/token" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                -d "username=${USERNAME}&password=${PASSWORD}")
            
            if ! echo "$token_response" | grep -q "access_token"; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Erreur d'authentification pour le polling${NC}" >&2
                    echo "$token_response" >&2
                else
                    echo "$token_response" >&2
                fi
                exit 1
            fi
            
            local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
            
            if [ -z "$token" ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Impossible d'extraire le token${NC}" >&2
                fi
                exit 1
            fi
            
            # Polling jusqu'√† ce que le statut soit "done" ou "error"
            local status="$initial_status"
            local max_attempts=3600  # 1 heure max (1 seconde par tentative)
            local attempt=0
            local poll_interval=2  # 2 secondes entre les tentatives
            
            while [ "$status" != "done" ] && [ "$status" != "error" ] && [ $attempt -lt $max_attempts ]; do
                sleep $poll_interval
                attempt=$((attempt + 1))
                
                local status_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
                
                if [ $? -eq 0 ]; then
                    status=$(echo "$status_response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
                    
                    if [ "$verbose" = "true" ]; then
                        # Afficher un point de progression toutes les 5 secondes
                        if [ $((attempt % 3)) -eq 0 ]; then
                            echo -e "${BLUE}.${NC}" >&2
                        fi
                    fi
                else
                    if [ "$verbose" = "true" ]; then
                        echo -e "${YELLOW}‚ö†Ô∏è  Erreur lors de la r√©cup√©ration du statut, nouvelle tentative...${NC}" >&2
                    fi
                fi
            done
            
            if [ "$verbose" = "true" ]; then
                echo "" >&2
            fi
            
            # R√©cup√©rer le r√©sultat final de la transcription
            local final_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
            
            if [ $? -ne 0 ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Impossible de r√©cup√©rer le r√©sultat final${NC}" >&2
                else
                    echo "{\"error\": \"Impossible de r√©cup√©rer le r√©sultat final\"}" >&2
                fi
                exit 1
            fi
            
            local final_status=$(echo "$final_response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
            
            # Si l'enrichissement est activ√© et que la transcription est termin√©e, attendre l'enrichissement
            if [ "$enrichment" = "true" ] && [ "$final_status" = "done" ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${GREEN}‚úì Transcription termin√©e${NC}" >&2
                    echo -e "${BLUE}‚è≥ Attente de la fin de l'enrichissement...${NC}" >&2
                fi
                
                # Polling jusqu'√† ce que enrichment_status soit "done" ou "error"
                local enrichment_status="pending"
                local enrichment_attempt=0
                local enrichment_max_attempts=3600  # 1 heure max
                
                while [ "$enrichment_status" != "done" ] && [ "$enrichment_status" != "error" ] && [ $enrichment_attempt -lt $enrichment_max_attempts ]; do
                    sleep $poll_interval
                    enrichment_attempt=$((enrichment_attempt + 1))
                    
                    local enrichment_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
                    
                    if [ $? -eq 0 ]; then
                        # Extraire enrichment_status depuis la r√©ponse
                        enrichment_status=$(echo "$enrichment_response" | grep -o '"enrichment_status":"[^"]*' | cut -d'"' -f4)
                        
                        # Si enrichment_status est null ou vide, c'est qu'il n'y a pas d'enrichissement
                        if [ -z "$enrichment_status" ] || [ "$enrichment_status" = "null" ]; then
                            enrichment_status="pending"
                        fi
                        
                        if [ "$verbose" = "true" ]; then
                            # Afficher un point de progression toutes les 5 secondes
                            if [ $((enrichment_attempt % 3)) -eq 0 ]; then
                                echo -e "${BLUE}.${NC}" >&2
                            fi
                        fi
                    else
                        if [ "$verbose" = "true" ]; then
                            echo -e "${YELLOW}‚ö†Ô∏è  Erreur lors de la r√©cup√©ration du statut, nouvelle tentative...${NC}" >&2
                        fi
                    fi
                done
                
                if [ "$verbose" = "true" ]; then
                    echo "" >&2
                fi
                
                # R√©cup√©rer le r√©sultat final avec l'enrichissement
                final_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
                
                if [ $? -ne 0 ]; then
                    if [ "$verbose" = "true" ]; then
                        echo -e "${RED}‚ùå Impossible de r√©cup√©rer le r√©sultat final de l'enrichissement${NC}" >&2
                    else
                        echo "{\"error\": \"Impossible de r√©cup√©rer le r√©sultat final de l'enrichissement\"}" >&2
                    fi
                    exit 1
                fi
                
                # V√©rifier si on a atteint la limite de tentatives pour l'enrichissement
                if [ $enrichment_attempt -ge $enrichment_max_attempts ]; then
                    if [ "$verbose" = "true" ]; then
                        echo -e "${YELLOW}‚ö†Ô∏è  Timeout: l'enrichissement prend plus de temps que pr√©vu${NC}" >&2
                    else
                        echo "{\"error\": \"Timeout: l'enrichissement prend plus de temps que pr√©vu\"}" >&2
                    fi
                    exit 1
                fi
            fi
            
            # Afficher le r√©sultat final en JSON
            if command -v jq &> /dev/null; then
                echo "$final_response" | jq '.'
            else
                echo "$final_response"
            fi
            
            if [ "$verbose" = "true" ]; then
                echo "" >&2
                if [ "$final_status" = "done" ]; then
                    echo -e "${GREEN}‚úì Transcription termin√©e avec succ√®s!${NC}" >&2
                    if [ "$enrichment" = "true" ]; then
                        local final_enrichment_status=$(echo "$final_response" | grep -o '"enrichment_status":"[^"]*' | cut -d'"' -f4)
                        if [ "$final_enrichment_status" = "done" ]; then
                            echo -e "${GREEN}‚úì Enrichissement termin√© avec succ√®s!${NC}" >&2
                        elif [ "$final_enrichment_status" = "error" ]; then
                            local enrichment_error=$(echo "$final_response" | grep -o '"enrichment_error":"[^"]*' | cut -d'"' -f4)
                            echo -e "${YELLOW}‚ö†Ô∏è  Enrichissement √©chou√©: ${enrichment_error}${NC}" >&2
                        fi
                    fi
                elif [ "$final_status" = "error" ]; then
                    local error_msg=$(echo "$final_response" | grep -o '"error_message":"[^"]*' | cut -d'"' -f4)
                    echo -e "${RED}‚ùå Transcription √©chou√©e: ${error_msg}${NC}" >&2
                fi
            fi
            
            # V√©rifier si on a atteint la limite de tentatives pour la transcription
            if [ $attempt -ge $max_attempts ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${YELLOW}‚ö†Ô∏è  Timeout: la transcription prend plus de temps que pr√©vu${NC}" >&2
                else
                    echo "{\"error\": \"Timeout: la transcription prend plus de temps que pr√©vu\"}" >&2
                fi
                exit 1
            fi
        fi
    else
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Erreur lors de la cr√©ation de la transcription${NC}" >&2
            echo "$response" >&2
        else
            echo "$response" >&2
        fi
        exit 1
    fi
}

# Action status
action_status() {
    local transcription_id=""
    local verbose="false"
    
    # Parser les arguments sp√©cifiques √† status
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_status_help
                exit 0
                ;;
            -tid|--transcription-id)
                transcription_id="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            -*)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Option inconnue: $1${NC}" >&2
                else
                    echo "{\"error\": \"Option inconnue: $1\"}" >&2
                fi
                show_status_help
                exit 1
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Argument inattendu: $1${NC}" >&2
                    echo -e "${YELLOW}Utilisez -tid/--transcription-id pour l'ID de la transcription${NC}" >&2
                else
                    echo "{\"error\": \"Argument inattendu: $1\"}" >&2
                fi
                show_status_help
                exit 1
                ;;
        esac
    done
    
    # V√©rifier que l'ID est fourni
    if [ -z "$transcription_id" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå ID de transcription requis${NC}" >&2
        else
            echo "{\"error\": \"ID de transcription requis\"}" >&2
        fi
        show_status_help
        exit 1
    fi
    
    # Demander le mot de passe si non fourni
    if [ -z "$PASSWORD" ]; then
        if [ "$verbose" = "true" ]; then
            echo -n "Mot de passe pour $USERNAME: "
        fi
        read -s PASSWORD
        if [ "$verbose" = "true" ]; then
            echo ""
        fi
    fi
    
    # Obtenir le token JWT
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üîê Authentification...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${API_URL}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${USERNAME}&password=${PASSWORD}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Erreur d'authentification${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        exit 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Impossible d'extraire le token${NC}" >&2
        fi
        exit 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}‚úì Authentification r√©ussie${NC}" >&2
    fi
    
    # R√©cup√©rer la transcription
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üì• R√©cup√©ration de la transcription '${transcription_id}'...${NC}" >&2
    fi
    local response=$(curl -s -X GET "${API_URL}/api/user/transcriptions/${transcription_id}" \
        -H "Authorization: Bearer ${token}")
    
    # V√©rifier si la transcription existe
    if echo "$response" | grep -q '"id"'; then
        # Toujours afficher le JSON
        if command -v jq &> /dev/null; then
            echo "$response" | jq '.'
        else
            echo "$response"
        fi
        
        # Afficher les messages verbeux si demand√©
        if [ "$verbose" = "true" ]; then
            local status=$(echo "$response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
            local project_name=$(echo "$response" | grep -o '"project_name":"[^"]*' | cut -d'"' -f4)
            local file_path=$(echo "$response" | grep -o '"file_path":"[^"]*' | cut -d'"' -f4)
            local text=$(echo "$response" | grep -o '"text":"[^"]*' | cut -d'"' -f4)
            
            echo "" >&2
            echo -e "${GREEN}‚úì Transcription trouv√©e${NC}" >&2
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >&2
            echo "ID: $transcription_id" >&2
            echo "Statut: $status" >&2
            echo "Projet: $project_name" >&2
            echo "Fichier: $(basename "$file_path")" >&2
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ" >&2
            echo "" >&2
            
            # Afficher le texte si disponible
            if [ -n "$text" ] && [ "$text" != "null" ]; then
                echo "üìù Transcription:" >&2
                echo "$text" | sed 's/\\n/\n/g' >&2
                echo "" >&2
            else
                if [ "$status" = "pending" ] || [ "$status" = "processing" ]; then
                    echo -e "${YELLOW}‚è≥ Transcription en cours...${NC}" >&2
                elif [ "$status" = "error" ]; then
                    local error_msg=$(echo "$response" | grep -o '"error_message":"[^"]*' | cut -d'"' -f4)
                    echo -e "${RED}‚ùå Erreur: ${error_msg}${NC}" >&2
                fi
            fi
        fi
    else
        # V√©rifier si c'est une erreur 404
        if echo "$response" | grep -q "not found"; then
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}‚ùå Transcription '${transcription_id}' non trouv√©e${NC}" >&2
            else
                echo "$response" >&2
            fi
        else
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}‚ùå Erreur lors de la r√©cup√©ration de la transcription${NC}" >&2
                echo "$response" >&2
            else
                echo "$response" >&2
            fi
        fi
        exit 1
    fi
}

# Action enrich
action_enrich() {
    local transcription_id=""
    local llm_model=""
    local text_correction=""
    local prompts_file=""
    local verbose="false"
    local wait_for_completion="false"
    
    # Parser les arguments sp√©cifiques √† enrich
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_enrich_help
                exit 0
                ;;
            -tid|--transcription-id)
                transcription_id="$2"
                shift 2
                ;;
            -m|--llm-model)
                llm_model="$2"
                shift 2
                ;;
            --text-correction)
                text_correction="true"
                shift
                ;;
            --prompts-file)
                prompts_file="$2"
                shift 2
                ;;
            --wait)
                wait_for_completion="true"
                shift
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            -*)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Option inconnue: $1${NC}" >&2
                else
                    echo "{\"error\": \"Option inconnue: $1\"}" >&2
                fi
                show_enrich_help
                exit 1
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Argument inattendu: $1${NC}" >&2
                    echo -e "${YELLOW}Utilisez -tid/--transcription-id pour l'ID de la transcription${NC}" >&2
                else
                    echo "{\"error\": \"Argument inattendu: $1\"}" >&2
                fi
                show_enrich_help
                exit 1
                ;;
        esac
    done
    
    # V√©rifier que l'ID est fourni
    if [ -z "$transcription_id" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå ID de transcription requis${NC}" >&2
        else
            echo "{\"error\": \"ID de transcription requis\"}" >&2
        fi
        show_enrich_help
        exit 1
    fi
    
    # Valider le mod√®le LLM si fourni
    if [ -n "$llm_model" ]; then
        case "$llm_model" in
            qwen2.5-7b-instruct|mistral-7b-instruct|phi-3-mini)
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Mod√®le LLM invalide: $llm_model${NC}" >&2
                    echo -e "${YELLOW}Mod√®les valides: qwen2.5-7b-instruct, mistral-7b-instruct, phi-3-mini${NC}" >&2
                else
                    echo "{\"error\": \"Mod√®le LLM invalide: $llm_model\"}" >&2
                fi
                exit 1
                ;;
        esac
    fi
    
    # Lire le fichier de prompts si fourni
    local enrichment_prompts=""
    if [ -n "$prompts_file" ]; then
        if [ ! -f "$prompts_file" ]; then
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}‚ùå Fichier de prompts introuvable: $prompts_file${NC}" >&2
            else
                echo "{\"error\": \"Fichier de prompts introuvable: $prompts_file\"}" >&2
            fi
            exit 1
        fi
        
        # V√©rifier que c'est du JSON valide
        if ! command -v jq &> /dev/null; then
            # Sans jq, on lit simplement le fichier
            enrichment_prompts=$(cat "$prompts_file")
        else
            # Avec jq, on valide le JSON
            if ! jq empty "$prompts_file" 2>/dev/null; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Fichier de prompts invalide (JSON invalide): $prompts_file${NC}" >&2
                else
                    echo "{\"error\": \"Fichier de prompts invalide (JSON invalide): $prompts_file\"}" >&2
                fi
                exit 1
            fi
            enrichment_prompts=$(cat "$prompts_file")
        fi
    fi
    
    # Demander le mot de passe si non fourni
    if [ -z "$PASSWORD" ]; then
        if [ "$verbose" = "true" ]; then
            echo -n "Mot de passe pour $USERNAME: "
        fi
        read -s PASSWORD
        if [ "$verbose" = "true" ]; then
            echo ""
        fi
    fi
    
    # Obtenir le token JWT
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üîê Authentification...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${API_URL}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${USERNAME}&password=${PASSWORD}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Erreur d'authentification${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        exit 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Impossible d'extraire le token${NC}" >&2
        fi
        exit 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}‚úì Authentification r√©ussie${NC}" >&2
    fi
    
    # Construire le body JSON pour la requ√™te
    local json_body="{"
    local first=true
    
    if [ -n "$llm_model" ]; then
        json_body="${json_body}\"llm_model\": \"${llm_model}\""
        first=false
    fi
    
    if [ -n "$text_correction" ]; then
        if [ "$first" = "false" ]; then
            json_body="${json_body}, "
        fi
        json_body="${json_body}\"text_correction\": ${text_correction}"
        first=false
    fi
    
    if [ -n "$enrichment_prompts" ]; then
        if [ "$first" = "false" ]; then
            json_body="${json_body}, "
        fi
        json_body="${json_body}\"enrichment_prompts\": ${enrichment_prompts}"
        first=false
    fi
    
    json_body="${json_body}}"
    
    # D√©clencher l'enrichissement
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üöÄ D√©clenchement de l'enrichissement pour la transcription '${transcription_id}'...${NC}" >&2
    fi
    
    local response=$(curl -s -X POST "${API_URL}/api/user/transcriptions/${transcription_id}/re-enrich" \
        -H "Authorization: Bearer ${token}" \
        -H "Content-Type: application/json" \
        -d "$json_body")
    
    # V√©rifier la r√©ponse
    if echo "$response" | grep -q '"task_id"'; then
        local task_id=$(echo "$response" | grep -o '"task_id":"[^"]*' | cut -d'"' -f4)
        
        # Si --wait n'est pas activ√©, afficher le JSON et sortir
        if [ "$wait_for_completion" != "true" ]; then
            # Toujours afficher le JSON
            if command -v jq &> /dev/null; then
                echo "$response" | jq '.'
            else
                echo "$response"
            fi
            
            # Afficher les messages verbeux si demand√©
            if [ "$verbose" = "true" ]; then
                local status=$(echo "$response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
                echo "" >&2
                echo -e "${GREEN}‚úì Enrichissement d√©clench√© avec succ√®s!${NC}" >&2
                echo "ID de t√¢che: $task_id" >&2
                echo "Statut: $status" >&2
                echo "" >&2
                echo "Pour suivre la progression:" >&2
                echo "  $0 --action=status -tid ${transcription_id}" >&2
            fi
        else
            # Mode --wait : attendre la fin de l'enrichissement
            if [ "$verbose" = "true" ]; then
                echo -e "${BLUE}‚è≥ Attente de la fin de l'enrichissement...${NC}" >&2
                echo "ID de transcription: $transcription_id" >&2
                echo "ID de t√¢che: $task_id" >&2
            fi
            
            # Polling jusqu'√† ce que enrichment_status soit "done" ou "error"
            local enrichment_status="pending"
            local max_attempts=3600  # 1 heure max (1 seconde par tentative)
            local attempt=0
            local poll_interval=2  # 2 secondes entre les tentatives
            
            while [ "$enrichment_status" != "done" ] && [ "$enrichment_status" != "error" ] && [ $attempt -lt $max_attempts ]; do
                sleep $poll_interval
                attempt=$((attempt + 1))
                
                local status_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
                
                if [ $? -eq 0 ]; then
                    # Extraire enrichment_status depuis la r√©ponse
                    enrichment_status=$(echo "$status_response" | grep -o '"enrichment_status":"[^"]*' | cut -d'"' -f4)
                    
                    # Si enrichment_status est null ou vide, c'est qu'il n'y a pas d'enrichissement
                    if [ -z "$enrichment_status" ] || [ "$enrichment_status" = "null" ]; then
                        enrichment_status="pending"
                    fi
                    
                    if [ "$verbose" = "true" ]; then
                        # Afficher un point de progression toutes les 5 secondes
                        if [ $((attempt % 3)) -eq 0 ]; then
                            echo -e "${BLUE}.${NC}" >&2
                        fi
                    fi
                else
                    if [ "$verbose" = "true" ]; then
                        echo -e "${YELLOW}‚ö†Ô∏è  Erreur lors de la r√©cup√©ration du statut, nouvelle tentative...${NC}" >&2
                    fi
                fi
            done
            
            if [ "$verbose" = "true" ]; then
                echo "" >&2
            fi
            
            # R√©cup√©rer le r√©sultat final
            local final_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
            
            if [ $? -eq 0 ]; then
                # Afficher le r√©sultat final en JSON
                if command -v jq &> /dev/null; then
                    echo "$final_response" | jq '.'
                else
                    echo "$final_response"
                fi
                
                if [ "$verbose" = "true" ]; then
                    local final_enrichment_status=$(echo "$final_response" | grep -o '"enrichment_status":"[^"]*' | cut -d'"' -f4)
                    echo "" >&2
                    if [ "$final_enrichment_status" = "done" ]; then
                        echo -e "${GREEN}‚úì Enrichissement termin√© avec succ√®s!${NC}" >&2
                    elif [ "$final_enrichment_status" = "error" ]; then
                        local error_msg=$(echo "$final_response" | grep -o '"enrichment_error":"[^"]*' | cut -d'"' -f4)
                        echo -e "${RED}‚ùå Enrichissement √©chou√©: ${error_msg}${NC}" >&2
                    fi
                fi
            else
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Impossible de r√©cup√©rer le r√©sultat final${NC}" >&2
                else
                    echo "{\"error\": \"Impossible de r√©cup√©rer le r√©sultat final\"}" >&2
                fi
                exit 1
            fi
            
            # V√©rifier si on a atteint la limite de tentatives
            if [ $attempt -ge $max_attempts ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${YELLOW}‚ö†Ô∏è  Timeout: l'enrichissement prend plus de temps que pr√©vu${NC}" >&2
                else
                    echo "{\"error\": \"Timeout: l'enrichissement prend plus de temps que pr√©vu\"}" >&2
                fi
                exit 1
            fi
        fi
    else
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Erreur lors du d√©clenchement de l'enrichissement${NC}" >&2
            echo "$response" >&2
        else
            echo "$response" >&2
        fi
        exit 1
    fi
}

# Action purge
action_purge() {
    local transcription_id=""
    local project_name=""
    local date_from=""
    local dry_run="false"
    local verbose="false"
    
    # Parser les arguments sp√©cifiques √† purge
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_purge_help
                exit 0
                ;;
            -tid|--transcription-id)
                transcription_id="$2"
                shift 2
                ;;
            -P|--project)
                project_name="$2"
                shift 2
                ;;
            -d|--date)
                date_from="$2"
                shift 2
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            -*)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Option inconnue: $1${NC}" >&2
                else
                    echo "{\"error\": \"Option inconnue: $1\"}" >&2
                fi
                show_purge_help
                exit 1
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Argument inattendu: $1${NC}" >&2
                else
                    echo "{\"error\": \"Argument inattendu: $1\"}" >&2
                fi
                show_purge_help
                exit 1
                ;;
        esac
    done
    
    # V√©rifier qu'au moins un crit√®re est fourni
    if [ -z "$transcription_id" ] && [ -z "$project_name" ] && [ -z "$date_from" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Au moins un crit√®re requis (transcription-id, project ou date)${NC}" >&2
        else
            echo "{\"error\": \"Au moins un crit√®re requis (transcription-id, project ou date)\"}" >&2
        fi
        show_purge_help
        exit 1
    fi
    
    # Demander le mot de passe si non fourni
    if [ -z "$PASSWORD" ]; then
        if [ "$verbose" = "true" ]; then
            echo -n "Mot de passe pour $USERNAME: "
        fi
        read -s PASSWORD
        if [ "$verbose" = "true" ]; then
            echo ""
        fi
    fi
    
    # Obtenir le token JWT
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üîê Authentification...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${API_URL}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${USERNAME}&password=${PASSWORD}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Erreur d'authentification${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        exit 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Impossible d'extraire le token${NC}" >&2
        fi
        exit 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}‚úì Authentification r√©ussie${NC}" >&2
    fi
    
    # Collecter les IDs de transcriptions √† supprimer
    local transcription_ids=()
    local project_for_api_key=""
    
    # Si un ID sp√©cifique est fourni
    if [ -n "$transcription_id" ]; then
        transcription_ids+=("$transcription_id")
        # R√©cup√©rer le projet de cette transcription pour obtenir la cl√© API
        if [ "$verbose" = "true" ]; then
            echo -e "${BLUE}üîç R√©cup√©ration des informations de la transcription...${NC}" >&2
        fi
        local trans_info=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
        if [ $? -eq 0 ]; then
            project_for_api_key=$(echo "$trans_info" | grep -o '"project_name":"[^"]*' | cut -d'"' -f4)
        else
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}‚ùå Impossible de r√©cup√©rer la transcription${NC}" >&2
            else
                echo "{\"error\": \"Impossible de r√©cup√©rer la transcription: ${transcription_id}\"}" >&2
            fi
            exit 1
        fi
    else
        # Lister les transcriptions selon les crit√®res
        if [ "$verbose" = "true" ]; then
            echo -e "${BLUE}üîç Recherche des transcriptions √† supprimer...${NC}" >&2
        fi
        
        # Construire l'URL de liste avec les filtres
        # Note: L'API limite limit √† 100 maximum
        local list_url="${API_URL}/api/user/transcriptions?limit=100"
        if [ -n "$project_name" ]; then
            list_url="${list_url}&project=${project_name}"
        fi
        
        # R√©cup√©rer toutes les transcriptions (avec pagination si n√©cessaire)
        local page=1
        
        while true; do
            local page_url="${list_url}&page=${page}"
            local response=$(curl -s -X GET "$page_url" \
                -H "Authorization: Bearer ${token}")
            
            # V√©rifier si la r√©ponse contient une erreur
            if echo "$response" | grep -q '"detail"'; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}‚ùå Erreur API:${NC}" >&2
                    echo "$response" | jq '.' >&2 2>/dev/null || echo "$response" >&2
                else
                    echo "$response" >&2
                fi
                exit 1
            fi
            
            # V√©rifier si la r√©ponse est un tableau JSON valide
            if ! echo "$response" | grep -q '^\['; then
                break
            fi
            
            # V√©rifier si le tableau est vide
            if command -v jq &> /dev/null; then
                local array_length=$(echo "$response" | jq 'length' 2>/dev/null || echo "0")
                if [ "$array_length" -eq 0 ]; then
                    break
                fi
            fi
            
            # Extraire les IDs et les dates des transcriptions
            # Utiliser jq si disponible pour parser le JSON, sinon utiliser grep
            if command -v jq &> /dev/null; then
                # Avec jq, on peut extraire les IDs et les dates facilement
                local page_data=$(echo "$response" | jq -r '.[] | "\(.id)|\(.created_at)"')
                
                if [ -z "$page_data" ]; then
                    break
                fi
                
                # Convertir la date de r√©f√©rence en timestamp si n√©cessaire
                local date_timestamp=""
                if [ -n "$date_from" ]; then
                    date_timestamp=$(date -d "$date_from" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$date_from" +%s 2>/dev/null || echo "")
                    if [ -z "$date_timestamp" ]; then
                        # Essayer avec format ISO
                        date_timestamp=$(date -d "$date_from" +%s 2>/dev/null || echo "")
                    fi
                    if [ -z "$date_timestamp" ]; then
                        if [ "$verbose" = "true" ]; then
                            echo -e "${RED}‚ùå Format de date invalide: $date_from${NC}" >&2
                        else
                            echo "{\"error\": \"Format de date invalide: $date_from\"}" >&2
                        fi
                        exit 1
                    fi
                fi
                
                # Traiter chaque transcription
                while IFS='|' read -r tid created_at; do
                    if [ -n "$tid" ]; then
                        # Filtrer par date si n√©cessaire
                        if [ -n "$date_from" ] && [ -n "$date_timestamp" ]; then
                            local trans_timestamp=$(date -d "$created_at" +%s 2>/dev/null || echo "")
                            if [ -n "$trans_timestamp" ] && [ "$trans_timestamp" -ge "$date_timestamp" ]; then
                                transcription_ids+=("$tid")
                            fi
                        else
                            transcription_ids+=("$tid")
                        fi
                    fi
                done <<< "$page_data"
            else
                # Sans jq, utiliser grep (moins pr√©cis mais fonctionne)
                local page_ids=$(echo "$response" | grep -o '"id":"[^"]*' | cut -d'"' -f4)
                
                if [ -z "$page_ids" ]; then
                    break
                fi
                
                # Si pas de filtre de date, ajouter tous les IDs
                if [ -z "$date_from" ]; then
                    for tid in $page_ids; do
                        transcription_ids+=("$tid")
                    done
                else
                    # Avec filtre de date, on doit r√©cup√©rer chaque transcription pour v√©rifier la date
                    for tid in $page_ids; do
                        local trans_response=$(get_transcription_status "$tid" "$token" "$API_URL")
                        if [ $? -eq 0 ]; then
                            local created_at=$(echo "$trans_response" | grep -o '"created_at":"[^"]*' | cut -d'"' -f4)
                            if [ -n "$created_at" ]; then
                                local date_timestamp=$(date -d "$date_from" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$date_from" +%s 2>/dev/null || echo "")
                                if [ -z "$date_timestamp" ]; then
                                    date_timestamp=$(date -d "$date_from" +%s 2>/dev/null || echo "")
                                fi
                                if [ -n "$date_timestamp" ]; then
                                    local trans_timestamp=$(date -d "$created_at" +%s 2>/dev/null || echo "")
                                    if [ -n "$trans_timestamp" ] && [ "$trans_timestamp" -ge "$date_timestamp" ]; then
                                        transcription_ids+=("$tid")
                                    fi
                                fi
                            fi
                        fi
                    done
                fi
            fi
            
            # V√©rifier s'il y a plus de pages (limite de 100 par page)
            local count=0
            if command -v jq &> /dev/null; then
                count=$(echo "$response" | jq 'length' 2>/dev/null || echo "0")
            else
                count=$(echo "$page_ids" | wc -l)
            fi
            
            if [ "$count" -lt 100 ]; then
                break
            fi
            page=$((page + 1))
        done
        
        # Si un projet est sp√©cifi√©, l'utiliser pour la cl√© API
        if [ -n "$project_name" ]; then
            project_for_api_key="$project_name"
        else
            # Si pas de projet sp√©cifi√© mais des transcriptions trouv√©es, utiliser le projet de la premi√®re
            if [ ${#transcription_ids[@]} -gt 0 ]; then
                local first_id="${transcription_ids[0]}"
                local first_trans=$(get_transcription_status "$first_id" "$token" "$API_URL")
                if [ $? -eq 0 ]; then
                    project_for_api_key=$(echo "$first_trans" | grep -o '"project_name":"[^"]*' | cut -d'"' -f4)
                fi
            fi
        fi
    fi
    
    # R√©cup√©rer la cl√© interne (n√©cessaire pour l'endpoint DELETE)
    # La cl√© interne est une configuration serveur, elle doit √™tre fournie dans ~/.vocalyx_config
    # Elle correspond √† INTERNAL_API_KEY dans docker-compose.yml ou config.ini
    local internal_key="${INTERNAL_API_KEY:-${VOCALYX_INTERNAL_KEY:-}}"
    
    if [ -z "$internal_key" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}‚ùå Cl√© interne requise pour la suppression${NC}" >&2
            echo -e "${YELLOW}   L'endpoint DELETE n√©cessite X-Internal-Key${NC}" >&2
            echo -e "${YELLOW}   D√©finissez INTERNAL_API_KEY ou VOCALYX_INTERNAL_KEY dans ~/.vocalyx_config${NC}" >&2
            echo -e "${YELLOW}   Exemple: INTERNAL_API_KEY=secret_key_pour_comms_internes_123456${NC}" >&2
        else
            echo "{\"error\": \"Cl√© interne requise pour la suppression. D√©finissez INTERNAL_API_KEY ou VOCALYX_INTERNAL_KEY dans votre configuration\"}" >&2
        fi
        exit 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}‚úì Cl√© interne trouv√©e${NC}" >&2
    fi
    
    # Afficher le nombre de transcriptions √† supprimer
    local count=${#transcription_ids[@]}
    
    if [ "$count" -eq 0 ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${YELLOW}‚ÑπÔ∏è  Aucune transcription trouv√©e √† supprimer${NC}" >&2
        else
            echo "{\"count\": 0, \"message\": \"Aucune transcription trouv√©e √† supprimer\"}"
        fi
        exit 0
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üìã ${count} transcription(s) trouv√©e(s)${NC}" >&2
    fi
    
    # Mode dry-run : afficher sans supprimer
    if [ "$dry_run" = "true" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${YELLOW}üîç Mode dry-run : affichage des transcriptions qui seraient supprim√©es${NC}" >&2
        fi
        
        local result_json="{\"dry_run\": true, \"count\": ${count}, \"transcription_ids\": ["
        local first=true
        for tid in "${transcription_ids[@]}"; do
            if [ "$first" = "false" ]; then
                result_json="${result_json}, "
            fi
            result_json="${result_json}\"${tid}\""
            first=false
        done
        result_json="${result_json}]}"
        
        if command -v jq &> /dev/null; then
            echo "$result_json" | jq '.'
        else
            echo "$result_json"
        fi
        
        if [ "$verbose" = "true" ]; then
            echo "" >&2
            echo "IDs des transcriptions qui seraient supprim√©es:" >&2
            for tid in "${transcription_ids[@]}"; do
                echo "  - $tid" >&2
            done
        fi
        exit 0
    fi
    
    # Supprimer les transcriptions
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}üóëÔ∏è  Suppression de ${count} transcription(s)...${NC}" >&2
    fi
    
    local deleted_count=0
    local failed_count=0
    local deleted_ids=()
    local failed_ids=()
    
    for tid in "${transcription_ids[@]}"; do
        # Utiliser la cl√© interne (l'endpoint DELETE n√©cessite X-Internal-Key)
        local delete_response
        delete_response=$(curl -s -X DELETE "${API_URL}/api/transcriptions/${tid}" \
            -H "X-Internal-Key: ${internal_key}")
        
        # V√©rifier si la suppression a r√©ussi
        if echo "$delete_response" | grep -q '"status":"deleted"'; then
            deleted_count=$((deleted_count + 1))
            deleted_ids+=("$tid")
            if [ "$verbose" = "true" ]; then
                echo -e "${GREEN}‚úì Supprim√©: ${tid}${NC}" >&2
            fi
        else
            failed_count=$((failed_count + 1))
            failed_ids+=("$tid")
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}‚ùå √âchec: ${tid}${NC}" >&2
                echo "$delete_response" >&2
            fi
        fi
    done
    
    # Afficher le r√©sultat
    local result_json="{\"deleted\": ${deleted_count}, \"failed\": ${failed_count}, \"total\": ${count}}"
    
    if command -v jq &> /dev/null; then
        echo "$result_json" | jq '.'
    else
        echo "$result_json"
    fi
    
    if [ "$verbose" = "true" ]; then
        echo "" >&2
        echo -e "${GREEN}‚úì ${deleted_count} transcription(s) supprim√©e(s)${NC}" >&2
        if [ "$failed_count" -gt 0 ]; then
            echo -e "${RED}‚ùå ${failed_count} √©chec(s)${NC}" >&2
        fi
    fi
    
    if [ "$failed_count" -gt 0 ]; then
        exit 1
    fi
}

# Fonction principale
main() {
    # La configuration est d√©j√† charg√©e au d√©but du script
    # load_config() peut √™tre utilis√©e pour recharger si n√©cessaire
    
    # Variables pour les options globales
    local action=""
    
    # Parser les arguments globaux
    while [[ $# -gt 0 ]]; do
        case $1 in
            --action=*)
                action="${1#*=}"
                shift
                ;;
            --action)
                action="$2"
                shift 2
                ;;
            -h|--help)
                # Si une action est d√©j√† d√©finie, laisser --help passer √† l'action
                if [ -n "$action" ]; then
                    break
                fi
                show_help
                exit 0
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            *)
                # Si pas d'action d√©finie, afficher l'aide
                if [ -z "$action" ]; then
                    echo -e "${RED}‚ùå Action requise. Utilisez --action=<action>${NC}" >&2
                    echo ""
                    show_help
                    exit 1
                fi
                # Passer les arguments restants √† l'action
                break
                ;;
        esac
    done
    
    # V√©rifier qu'une action est sp√©cifi√©e
    if [ -z "$action" ]; then
        echo -e "${RED}‚ùå Action requise. Utilisez --action=<action>${NC}" >&2
        echo ""
        show_help
        exit 1
    fi
    
    # Ex√©cuter l'action appropri√©e
    case "$action" in
        transcribe)
            action_transcribe "$@"
            ;;
        status)
            action_status "$@"
            ;;
        enrich)
            action_enrich "$@"
            ;;
        purge)
            action_purge "$@"
            ;;
        *)
            echo -e "${RED}‚ùå Action inconnue: $action${NC}" >&2
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Ex√©cuter la fonction principale
main "$@"

