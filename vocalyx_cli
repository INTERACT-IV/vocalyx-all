#!/bin/bash

# CLI Vocalyx - Command line tool for Vocalyx
# Usage: ./vocalyx_cli --action=transcribe <audio_file> <project_name> [options]

set -e

# Configuration file path
CONFIG_FILE="${HOME}/.vocalyx_config"

# Load configuration from file if it exists
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
fi

# Default configuration (after loading config file)
API_URL="${VOCALYX_API_URL:-http://localhost:8000}"
USERNAME="${VOCALYX_USERNAME:-admin}"
PASSWORD="${VOCALYX_PASSWORD:-}"

# Colors for messages
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# General help function
show_help() {
    cat << EOF
Usage: $0 --action=<action> [arguments] [options]

Available actions:
  transcribe    Create an audio transcription
  status        Get status and result of a transcription
  enrich        Trigger enrichment of a transcription
  purge         Delete transcriptions based on criteria

Global options:
  -u, --username USERNAME    Username (default: admin or from config)
  -p, --password PASSWORD    Password (or from config)
  -a, --api-url URL          API URL (default: http://localhost:8000)
  -h, --help                 Show this help

Environment variables:
  VOCALYX_API_URL            Vocalyx API URL
  VOCALYX_USERNAME           Username
  VOCALYX_PASSWORD           Password
  VOCALYX_PROJECT_API_KEY    Project API Key (if provided, skips authentication)

Configuration:
  The script can read credentials from ~/.vocalyx_config:
    VOCALYX_USERNAME=admin
    VOCALYX_PASSWORD=my_password
    VOCALYX_API_URL=http://localhost:8000

For specific action help:
  $0 --action=transcribe --help
  $0 --action=status --help
  $0 --action=enrich --help
  $0 --action=purge --help
EOF
}

# Help function for action transcribe
show_transcribe_help() {
    cat << EOF
Action: transcribe

Create an audio transcription on Vocalyx.

Usage: $0 --action=transcribe -f <audio_file> -P <project_name> [options]

Required arguments:
  -f, --file FILE            Path to audio file to transcribe
  -P, --project PROJECT      Vocalyx project name

Transcribe specific options:
  -m, --model MODEL          Whisper model (tiny|base|small|medium|large-v3-turbo, default: small)
  --no-vad                   Disable VAD (Voice Activity Detection)
  --diarization              Enable speaker diarization
  --enrichment               Enable automatic enrichment after transcription (default prompts)
  --llm-model MODEL          LLM model for enrichment (qwen2.5-7b-instruct|mistral-7b-instruct|phi-3-mini)
  --wait                     Wait for transcription completion (and enrichment if enabled) and show result (synchronous mode)
  -v, --verbose              Show detailed messages (default: JSON only)

Global options:
  -u, --username USERNAME    Username (default: admin or from config)
  -p, --password PASSWORD    Password (or from config)
  -a, --api-url URL          API URL (default: http://localhost:8000)

Examples:
  $0 --action=transcribe -f audio.wav -P ISICOMTECH
  $0 --action=transcribe --file audio.mp3 --project MY_PROJECT --model medium --diarization
  $0 --action=transcribe -f audio.wav -P ISICOMTECH --no-vad
  $0 --action=transcribe -f audio.wav -P ISICOMTECH --wait
  $0 --action=transcribe -f audio.wav -P ISICOMTECH --enrichment --wait
  $0 --action=transcribe -f audio.wav -P ISICOMTECH --enrichment --llm-model qwen2.5-7b-instruct --wait
EOF
}

# Help function for action status
show_status_help() {
    cat << EOF
Action: status

Get status and result of a transcription.

Usage: $0 --action=status -tid <transcription_id> [options]

Required arguments:
  -tid, --transcription-id ID    ID of the transcription to retrieve

Status specific options:
  -v, --verbose              Show detailed messages (default: JSON only)

Global options:
  -u, --username USERNAME    Username (default: admin or from config)
  -p, --password PASSWORD    Password (or from config)
  -a, --api-url URL          API URL (default: http://localhost:8000)

Examples:
  $0 --action=status -tid abc123-def456-ghi789
  $0 --action=status --transcription-id abc123-def456-ghi789
EOF
}

# Help function for action enrich
show_enrich_help() {
    cat << EOF
Action: enrich

Trigger enrichment of an existing transcription.

Usage: $0 --action=enrich -tid <transcription_id> [options]

Required arguments:
  -tid, --transcription-id ID    ID of the transcription to enrich

Enrich specific options:
  -m, --llm-model MODEL         LLM Model (qwen2.5-7b-instruct|mistral-7b-instruct|phi-3-mini)
  --text-correction              Enable text correction (spelling, grammar)
  --prompts-file FILE           JSON file containing custom prompts
  --wait                         Wait for enrichment completion and show result (synchronous mode)
  -v, --verbose                 Show detailed messages (default: JSON only)

Global options:
  -u, --username USERNAME    Username (default: admin or from config)
  -p, --password PASSWORD    Password (or from config)
  -a, --api-url URL          API URL (default: http://localhost:8000)

Examples:
  $0 --action=enrich -tid abc123-def456-ghi789
  $0 --action=enrich --transcription-id abc123 --llm-model qwen2.5-7b-instruct --text-correction
  $0 --action=enrich -tid abc123 -m phi-3-mini --prompts-file prompts.json
  $0 --action=enrich -tid abc123 --wait
EOF
}

# Help function for action purge
show_purge_help() {
    cat << EOF
Action: purge

Delete transcriptions based on criteria (audio files included).

Usage: $0 --action=purge [options]

Options (at least one required):
  -tid, --transcription-id ID    ID of the transcription to delete
  -P, --project PROJECT          Delete all transcriptions of a project
  -d, --date DATE                Delete transcriptions from this date (format: YYYY-MM-DD or YYYY-MM-DDTHH:MM:SS)
  --dry-run                      Show transcriptions that would be deleted without deleting them
  -v, --verbose                  Show detailed messages (default: JSON only)

Global options:
  -u, --username USERNAME    Username (default: admin or from config)
  -p, --password PASSWORD    Password (or from config)
  -a, --api-url URL          API URL (default: http://localhost:8000)

Examples:
  $0 --action=purge -tid abc123-def456-ghi789
  $0 --action=purge -P ISICOMTECH
  $0 --action=purge -d 2024-01-01
  $0 --action=purge -P ISICOMTECH -d 2024-01-01
  $0 --action=purge -P ISICOMTECH --dry-run
EOF
}

# Load configuration from file (function to reload if necessary)
load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        # Reset variables after reload
        API_URL="${VOCALYX_API_URL:-${API_URL:-http://localhost:8000}}"
        USERNAME="${VOCALYX_USERNAME:-${USERNAME:-admin}}"
        PASSWORD="${VOCALYX_PASSWORD:-${PASSWORD:-}}"
        # Internal key can be defined via INTERNAL_API_KEY or VOCALYX_INTERNAL_KEY
        # It is exported to be accessible in functions
        export INTERNAL_API_KEY="${INTERNAL_API_KEY:-${VOCALYX_INTERNAL_KEY:-}}"
        echo -e "${BLUE}âœ“ Configuration chargÃ©e depuis $CONFIG_FILE${NC}" >&2
    fi
}

# Helper function to get project API key via JWT
get_project_api_key() {
    local username=$1
    local password=$2
    local api_url=$3
    local project_name=$4
    local verbose=${5:-false}
    
    # Get JWT token
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ” Authentification...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${api_url}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${username}&password=${password}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Erreur d'authentification${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        return 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Impossible d'extraire le token${NC}" >&2
        fi
        return 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}âœ“ Authentification rÃ©ussie${NC}" >&2
    fi
    
    # Get projects with their API keys
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ” RÃ©cupÃ©ration de la clÃ© API du projet '${project_name}'...${NC}" >&2
    fi
    local projects_response=$(curl -s -X GET "${api_url}/api/user/projects" \
        -H "Authorization: Bearer ${token}")
    
    # Extract project API key
    local api_key=$(echo "$projects_response" | grep -o "\"name\":\"${project_name}\"[^}]*\"api_key\":\"[^\"]*" | grep -o '"api_key":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$api_key" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Projet '${project_name}' non trouvÃ© ou non accessible${NC}" >&2
            echo -e "${YELLOW}Projets disponibles:${NC}" >&2
            echo "$projects_response" | grep -o '"name":"[^"]*' | cut -d'"' -f4 | sed 's/^/  - /' >&2
        else
            echo "$projects_response" >&2
        fi
        return 1
    fi
    
    echo "$api_key"
}

# Get admin project API key (used as internal key for DELETE)
get_admin_api_key() {
    local username=$1
    local password=$2
    local api_url=$3
    local verbose=${4:-false}
    
    # Get JWT token
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ” Authentification...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${api_url}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${username}&password=${password}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Erreur d'authentification${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        return 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Impossible d'extraire le token${NC}" >&2
        fi
        return 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}âœ“ Authentification rÃ©ussie${NC}" >&2
    fi
    
    # Get admin project API key
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ”‘ RÃ©cupÃ©ration de la clÃ© API du projet admin...${NC}" >&2
    fi
    local admin_response=$(curl -s -X GET "${api_url}/api/admin/admin-api-key" \
        -H "Authorization: Bearer ${token}")
    
    # Extract admin project API key
    local admin_api_key=$(echo "$admin_response" | grep -o '"api_key":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$admin_api_key" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Impossible de rÃ©cupÃ©rer la clÃ© API du projet admin${NC}" >&2
            echo "$admin_response" >&2
        else
            echo "$admin_response" >&2
        fi
        return 1
    fi
    
    echo "$admin_api_key"
}

# Helper function to get transcription status with JWT token
get_transcription_status() {
    local transcription_id=$1
    local token=$2
    local api_url=$3
    
    local response=$(curl -s -X GET "${api_url}/api/user/transcriptions/${transcription_id}" \
        -H "Authorization: Bearer ${token}")
    
    if echo "$response" | grep -q '"id"'; then
        echo "$response"
        return 0
    else
        return 1
    fi
}

# Process a single file (transcription + optional enrichment)
# Returns 0 on success, 1 on error
process_single_file() {
    local audio_file="$1"
    local project_name="$2"
    local whisper_model="$3"
    local use_vad="$4"
    local diarization="$5"
    local enrichment="$6"
    local llm_model="$7"
    local wait_for_completion="$8"
    local verbose="$9"
    local api_key="${10}"
    local password="${11}"  # Pass the global PASSWORD variable
    
    # Check that file exists
    if [ ! -f "$audio_file" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Audio file not found: $audio_file${NC}" >&2
        else
            echo "{\"error\": \"Audio file not found: $audio_file\"}" >&2
        fi
        return 1
    fi

    # Automatic MP3 -> WAV conversion (8kHz a-law) via sox
    local tmp_wav=""
    if [[ "${audio_file,,}" == *.mp3 ]]; then
        if ! command -v sox &> /dev/null; then
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}âŒ MP3 file detected but 'sox' is not installed.${NC}" >&2
                echo -e "${YELLOW}Please install sox: sudo apt install sox${NC}" >&2
            else
                echo "{\"error\": \"MP3 file detected but 'sox' is not installed\"}" >&2
            fi
            return 1
        fi

        if [ "$verbose" = "true" ]; then
            echo -e "${BLUE}ðŸŽµ Converting MP3 -> WAV (8000Hz a-law) in progress...${NC}" >&2
        fi

        tmp_wav=$(mktemp --suffix=.wav)
        if ! sox "$audio_file" -r 8000 -e a-law "$tmp_wav"; then
             if [ "$verbose" = "true" ]; then
                echo -e "${RED}âŒ Error during sox conversion.${NC}" >&2
            else
                echo "{\"error\": \"Error during sox conversion\"}" >&2
            fi
            rm -f "$tmp_wav"
            return 1
        fi

        # Use temporary file
        audio_file="$tmp_wav"
    fi
    
    # Create transcription
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ“¤ Sending audio file...${NC}" >&2
        echo -e "   File: $audio_file" >&2
        echo -e "   Project: $project_name" >&2
        echo -e "   Model: $whisper_model" >&2
        if [ "$enrichment" = "true" ]; then
            echo -e "   Enrichment: enabled" >&2
            if [ -n "$llm_model" ]; then
                echo -e "   LLM Model: $llm_model" >&2
            fi
        fi
    fi
    
    # Build curl request with parameters
    local response
    if [ -n "$llm_model" ]; then
        response=$(curl -s -X POST "${API_URL}/api/transcriptions" \
            -H "X-API-Key: ${api_key}" \
            -F "file=@${audio_file}" \
            -F "project_name=${project_name}" \
            -F "whisper_model=${whisper_model}" \
            -F "use_vad=${use_vad}" \
            -F "diarization=${diarization}" \
            -F "enrichment=${enrichment}" \
            -F "llm_model=${llm_model}")
    else
        response=$(curl -s -X POST "${API_URL}/api/transcriptions" \
            -H "X-API-Key: ${api_key}" \
            -F "file=@${audio_file}" \
            -F "project_name=${project_name}" \
            -F "whisper_model=${whisper_model}" \
            -F "use_vad=${use_vad}" \
            -F "diarization=${diarization}" \
            -F "enrichment=${enrichment}")
    fi
    
    # Check response
    if echo "$response" | grep -q '"id"'; then
        local transcription_id=$(echo "$response" | grep -o '"id":"[^"]*' | cut -d'"' -f4)
        local initial_status=$(echo "$response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        
        # If --wait is not enabled, print JSON and return
        if [ "$wait_for_completion" != "true" ]; then
            # Always print JSON
            if command -v jq &> /dev/null; then
                echo "$response" | jq '.'
            else
                echo "$response"
            fi
            
            # Show verbose messages if requested
            if [ "$verbose" = "true" ]; then
                echo "" >&2
                echo -e "${GREEN}âœ“ Transcription created successfully!${NC}" >&2
                echo "Transcription ID: $transcription_id" >&2
                echo "Status: $initial_status" >&2
                echo "" >&2
                echo "To follow progress:" >&2
                echo "  $0 --action=status -tid ${transcription_id}" >&2
                echo "" >&2
                echo "Or visit the dashboard:" >&2
                echo "  ${API_URL%:8000}:8080" >&2
            fi
            
            # Cleanup temporary wav if exists
            if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then
                rm -f "$tmp_wav"
            fi
            return 0
        else
            # --wait mode: wait for transcription completion
            if [ "$verbose" = "true" ]; then
                echo -e "${BLUE}â³ Waiting for transcription completion...${NC}" >&2
                echo "ID: $transcription_id" >&2
                echo "Initial status: $initial_status" >&2
            fi
            
            # Get JWT token for polling
            local token_response=$(curl -s -X POST "${API_URL}/api/auth/token" \
                -H "Content-Type: application/x-www-form-urlencoded" \
                -d "username=${USERNAME}&password=${password}")
            
            if ! echo "$token_response" | grep -q "access_token"; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Authentication error for polling${NC}" >&2
                    echo "$token_response" >&2
                else
                    echo "$token_response" >&2
                fi
                if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then rm -f "$tmp_wav"; fi
                return 1
            fi
            
            local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
            
            if [ -z "$token" ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unable to extract token${NC}" >&2
                fi
                if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then rm -f "$tmp_wav"; fi
                return 1
            fi
            
            # Poll until status is "done" or "error"
            local status="$initial_status"
            local max_attempts=3600  # 1 hour max
            local attempt=0
            local poll_interval=2
            
            while [ "$status" != "done" ] && [ "$status" != "error" ] && [ $attempt -lt $max_attempts ]; do
                sleep $poll_interval
                attempt=$((attempt + 1))
                
                local status_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
                
                if [ $? -eq 0 ]; then
                    status=$(echo "$status_response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
                    
                    if [ "$verbose" = "true" ]; then
                        if [ $((attempt % 3)) -eq 0 ]; then
                            echo -e "${BLUE}.${NC}" >&2
                        fi
                    fi
                else
                    if [ "$verbose" = "true" ]; then
                        echo -e "${YELLOW}âš ï¸  Error retrieving status, retrying...${NC}" >&2
                    fi
                fi
            done
            
            if [ "$verbose" = "true" ]; then
                echo "" >&2
            fi
            
            # Retrieve final result
            local final_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
            
            if [ $? -ne 0 ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unable to retrieve final result${NC}" >&2
                else
                    echo "{\"error\": \"Unable to retrieve final result\"}" >&2
                fi
                if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then rm -f "$tmp_wav"; fi
                return 1
            fi
            
            local final_status=$(echo "$final_response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
            
            # If enrichment is enabled and transcription is done, wait for enrichment
            if [ "$enrichment" = "true" ] && [ "$final_status" = "done" ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${GREEN}âœ“ Transcription completed${NC}" >&2
                    echo -e "${BLUE}â³ Waiting for enrichment completion...${NC}" >&2
                fi
                
                # Polling for enrichment
                local enrichment_status="pending"
                local enrichment_attempt=0
                local enrichment_max_attempts=3600
                
                while [ "$enrichment_status" != "done" ] && [ "$enrichment_status" != "error" ] && [ $enrichment_attempt -lt $enrichment_max_attempts ]; do
                    sleep $poll_interval
                    enrichment_attempt=$((enrichment_attempt + 1))
                    
                    local enrichment_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
                    
                    if [ $? -eq 0 ]; then
                        enrichment_status=$(echo "$enrichment_response" | grep -o '"enrichment_status":"[^"]*' | cut -d'"' -f4)
                        
                        if [ -z "$enrichment_status" ] || [ "$enrichment_status" = "null" ]; then
                            enrichment_status="pending"
                        fi
                        
                        if [ "$verbose" = "true" ]; then
                            if [ $((enrichment_attempt % 3)) -eq 0 ]; then
                                echo -e "${BLUE}.${NC}" >&2
                            fi
                        fi
                    else
                        if [ "$verbose" = "true" ]; then
                            echo -e "${YELLOW}âš ï¸  Error retrieving status, retrying...${NC}" >&2
                        fi
                    fi
                done
                
                if [ "$verbose" = "true" ]; then
                    echo "" >&2
                fi
                
                final_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
                
                if [ $? -ne 0 ]; then
                    if [ "$verbose" = "true" ]; then
                        echo -e "${RED}âŒ Unable to retrieve final enrichment result${NC}" >&2
                    else
                        echo "{\"error\": \"Unable to retrieve final enrichment result\"}" >&2
                    fi
                    if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then rm -f "$tmp_wav"; fi
                    return 1
                fi
                
                if [ $enrichment_attempt -ge $enrichment_max_attempts ]; then
                    if [ "$verbose" = "true" ]; then
                        echo -e "${YELLOW}âš ï¸  Timeout: enrichment is taking longer than expected${NC}" >&2
                    else
                        echo "{\"error\": \"Timeout: enrichment is taking longer than expected\"}" >&2
                    fi
                    if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then rm -f "$tmp_wav"; fi
                    return 1
                fi
            fi
            
            # Print final JSON
            if command -v jq &> /dev/null; then
                echo "$final_response" | jq '.'
            else
                echo "$final_response"
            fi
            
            if [ "$verbose" = "true" ]; then
                echo "" >&2
                if [ "$final_status" = "done" ]; then
                    echo -e "${GREEN}âœ“ Transcription completed successfully!${NC}" >&2
                    if [ "$enrichment" = "true" ]; then
                        local final_enrichment_status=$(echo "$final_response" | grep -o '"enrichment_status":"[^"]*' | cut -d'"' -f4)
                        if [ "$final_enrichment_status" = "done" ]; then
                            echo -e "${GREEN}âœ“ Enrichment completed successfully!${NC}" >&2
                        elif [ "$final_enrichment_status" = "error" ]; then
                            local enrichment_error=$(echo "$final_response" | grep -o '"enrichment_error":"[^"]*' | cut -d'"' -f4)
                            echo -e "${YELLOW}âš ï¸  Enrichment failed: ${enrichment_error}${NC}" >&2
                        fi
                    fi
                elif [ "$final_status" = "error" ]; then
                    local error_msg=$(echo "$final_response" | grep -o '"error_message":"[^"]*' | cut -d'"' -f4)
                    echo -e "${RED}âŒ Transcription failed: ${error_msg}${NC}" >&2
                fi
            fi
            
            if [ $attempt -ge $max_attempts ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${YELLOW}âš ï¸  Timeout: transcription is taking longer than expected${NC}" >&2
                else
                    echo "{\"error\": \"Timeout: transcription is taking longer than expected\"}" >&2
                fi
                if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then rm -f "$tmp_wav"; fi
                return 1
            fi
        fi
        
        # Cleanup temporary wav if exists
        if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then
            rm -f "$tmp_wav"
        fi
        return 0
    else
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Error creating transcription${NC}" >&2
            echo "$response" >&2
        else
            echo "$response" >&2
        fi
        if [ -n "$tmp_wav" ] && [ -f "$tmp_wav" ]; then
            rm -f "$tmp_wav"
        fi
        return 1
    fi
}

# Action transcribe
action_transcribe() {
    local audio_file=""
    local project_name=""
    local whisper_model="small"
    local use_vad="true"
    local diarization="false"
    local enrichment="false"
    local llm_model=""
    local wait_for_completion="false"
    local verbose="false"
    
    # Parse transcribe arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_transcribe_help
                exit 0
                ;;
            -f|--file)
                audio_file="$2"
                shift 2
                ;;
            -P|--project)
                project_name="$2"
                shift 2
                ;;
            -m|--model)
                whisper_model="$2"
                shift 2
                ;;
            --no-vad)
                use_vad="false"
                shift
                ;;
            --diarization)
                diarization="true"
                shift
                ;;
            --enrichment)
                enrichment="true"
                shift
                ;;
            --llm-model)
                llm_model="$2"
                shift 2
                ;;
            --wait)
                wait_for_completion="true"
                shift
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            -*)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unknown option: $1${NC}" >&2
                else
                    echo "{\"error\": \"Unknown option: $1\"}" >&2
                fi
                show_transcribe_help
                exit 1
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unexpected argument: $1${NC}" >&2
                    echo -e "${YELLOW}Use -f/--file for the file and -P/--project for the project${NC}" >&2
                else
                    echo "{\"error\": \"Unexpected argument: $1\"}" >&2
                fi
                show_transcribe_help
                exit 1
                ;;
        esac
    done
    
    # Check required arguments
    if [ -z "$audio_file" ] || [ -z "$project_name" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Missing arguments${NC}" >&2
        else
            echo "{\"error\": \"Missing arguments: audio file and project required\"}" >&2
        fi
        show_transcribe_help
        exit 1
    fi
    
    # Validate LLM model if provided
    if [ -n "$llm_model" ]; then
        case "$llm_model" in
            qwen2.5-7b-instruct|mistral-7b-instruct|phi-3-mini)
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Invalid LLM model: $llm_model${NC}" >&2
                    echo -e "${YELLOW}Valid models: qwen2.5-7b-instruct, mistral-7b-instruct, phi-3-mini${NC}" >&2
                else
                    echo "{\"error\": \"Invalid LLM model: $llm_model\"}" >&2
                fi
                exit 1
                ;;
        esac
    fi
    
    # Ask for password if not provided
    if [ -z "$PASSWORD" ]; then
        if [ "$verbose" = "true" ]; then
            echo -n "Password for $USERNAME: "
        fi
        read -s PASSWORD
        if [ "$verbose" = "true" ]; then
            echo ""
        fi
    fi
    
    # Get API key (or use the one provided in environment variable)
    local api_key="${VOCALYX_PROJECT_API_KEY}"
    
    if [ -z "$api_key" ]; then
        api_key=$(get_project_api_key "$USERNAME" "$PASSWORD" "$API_URL" "$project_name" "$verbose")
        if [ $? -ne 0 ]; then
            exit 1
        fi
    else
        if [ "$verbose" = "true" ]; then
            echo -e "${GREEN}âœ“ Using provided API key${NC}" >&2
        fi
    fi
    
    # Check if audio_file is a directory
    if [ -d "$audio_file" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${BLUE}ðŸ“‚ Directory detected. Searching for .wav and .mp3 files in: $audio_file${NC}" >&2
        fi
        
        # Find files recursively
        local files=()
        while IFS= read -r -d '' file; do
            files+=("$file")
        done < <(find "$audio_file" -type f \( -iname "*.wav" -o -iname "*.mp3" \) -print0)
        
        local count=${#files[@]}
        if [ "$count" -eq 0 ]; then
             if [ "$verbose" = "true" ]; then
                echo -e "${YELLOW}â„¹ï¸  No matching files found in $audio_file${NC}" >&2
            else
                echo "{\"error\": \"No matching files found in $audio_file\"}" >&2
            fi
            exit 0
        fi
        
        if [ "$verbose" = "true" ]; then
            echo -e "${BLUE}ðŸ“‹ Processing $count files...${NC}" >&2
        fi
        
        local success_count=0
        local failure_count=0
        
        for file in "${files[@]}"; do
            if [ "$verbose" = "true" ]; then
                echo -e "${BLUE}âž¡ï¸  Processing: $file${NC}" >&2
            fi
            
            if process_single_file "$file" "$project_name" "$whisper_model" "$use_vad" "$diarization" "$enrichment" "$llm_model" "$wait_for_completion" "$verbose" "$api_key" "$PASSWORD"; then
                success_count=$((success_count + 1))
            else
                failure_count=$((failure_count + 1))
            fi
        done
        
        if [ "$verbose" = "true" ]; then
            echo "" >&2
            echo -e "${GREEN}âœ“ Completed: $success_count succeeded, $failure_count failed${NC}" >&2
        else
            echo "{\"summary\": {\"succeeded\": $success_count, \"failed\": $failure_count}}"
        fi
        
        if [ $failure_count -gt 0 ]; then
            exit 1
        fi
    else
        # Single file
        process_single_file "$audio_file" "$project_name" "$whisper_model" "$use_vad" "$diarization" "$enrichment" "$llm_model" "$wait_for_completion" "$verbose" "$api_key" "$PASSWORD"
        exit $?
    fi
}

# Action status
action_status() {
    local transcription_id=""
    local verbose="false"
    
    # Parse status-specific arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_status_help
                exit 0
                ;;
            -tid|--transcription-id)
                transcription_id="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            -*)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unknown option: $1${NC}" >&2
                else
                    echo "{\"error\": \"Unknown option: $1\"}" >&2
                fi
                show_status_help
                exit 1
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unexpected argument: $1${NC}" >&2
                    echo -e "${YELLOW}Use -tid/--transcription-id for the transcription ID${NC}" >&2
                else
                    echo "{\"error\": \"Unexpected argument: $1\"}" >&2
                fi
                show_status_help
                exit 1
                ;;
        esac
    done
    
    # Check that ID is provided
    if [ -z "$transcription_id" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Transcription ID required${NC}" >&2
        else
            echo "{\"error\": \"Transcription ID required\"}" >&2
        fi
        show_status_help
        exit 1
    fi
    
    # Ask for password if not provided
    if [ -z "$PASSWORD" ]; then
        if [ "$verbose" = "true" ]; then
            echo -n "Password for $USERNAME: "
        fi
        read -s PASSWORD
        if [ "$verbose" = "true" ]; then
            echo ""
        fi
    fi
    
    # Obtenir le token JWT
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ” Authentification...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${API_URL}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${USERNAME}&password=${PASSWORD}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Erreur d'authentification${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        exit 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Unable to extract token${NC}" >&2
        fi
        exit 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}âœ“ Authentication successful${NC}" >&2
    fi
    
    # Retrieve transcription
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ“¥ Retrieving transcription '${transcription_id}'...${NC}" >&2
    fi
    local response=$(curl -s -X GET "${API_URL}/api/user/transcriptions/${transcription_id}" \
        -H "Authorization: Bearer ${token}")
    
    # Check if transcription exists
    if echo "$response" | grep -q '"id"'; then
        # Always print JSON
        if command -v jq &> /dev/null; then
            echo "$response" | jq '.'
        else
            echo "$response"
        fi
        
        # Show verbose messages if requested
        if [ "$verbose" = "true" ]; then
            local status=$(echo "$response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
            local project_name=$(echo "$response" | grep -o '"project_name":"[^"]*' | cut -d'"' -f4)
            local file_path=$(echo "$response" | grep -o '"file_path":"[^"]*' | cut -d'"' -f4)
            local text=$(echo "$response" | grep -o '"text":"[^"]*' | cut -d'"' -f4)
            
            echo "" >&2
            echo -e "${GREEN}âœ“ Transcription found${NC}" >&2
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
            echo "ID: $transcription_id" >&2
            echo "Status: $status" >&2
            echo "Project: $project_name" >&2
            echo "File: $(basename "$file_path")" >&2
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
            echo "" >&2
            
            # Print text if available
            if [ -n "$text" ] && [ "$text" != "null" ]; then
                echo "ðŸ“ Transcription:" >&2
                echo "$text" | sed 's/\\n/\n/g' >&2
                echo "" >&2
            else
                if [ "$status" = "pending" ] || [ "$status" = "processing" ]; then
                    echo -e "${YELLOW}â³ Transcription in progress...${NC}" >&2
                elif [ "$status" = "error" ]; then
                    local error_msg=$(echo "$response" | grep -o '"error_message":"[^"]*' | cut -d'"' -f4)
                    echo -e "${RED}âŒ Error: ${error_msg}${NC}" >&2
                fi
            fi
        fi
    else
        # Check if it is a 404 error
        if echo "$response" | grep -q "not found"; then
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}âŒ Transcription '${transcription_id}' not found${NC}" >&2
            else
                echo "$response" >&2
            fi
        else
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}âŒ Error retrieving transcription${NC}" >&2
                echo "$response" >&2
            else
                echo "$response" >&2
            fi
        fi
        exit 1
    fi
}

# Action enrich
action_enrich() {
    local transcription_id=""
    local llm_model=""
    local text_correction=""
    local prompts_file=""
    local verbose="false"
    local wait_for_completion="false"
    
    # Parse enrich-specific arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_enrich_help
                exit 0
                ;;
            -tid|--transcription-id)
                transcription_id="$2"
                shift 2
                ;;
            -m|--llm-model)
                llm_model="$2"
                shift 2
                ;;
            --text-correction)
                text_correction="true"
                shift
                ;;
            --prompts-file)
                prompts_file="$2"
                shift 2
                ;;
            --wait)
                wait_for_completion="true"
                shift
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            -*)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unknown option: $1${NC}" >&2
                else
                    echo "{\"error\": \"Unknown option: $1\"}" >&2
                fi
                show_enrich_help
                exit 1
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unexpected argument: $1${NC}" >&2
                    echo -e "${YELLOW}Use -tid/--transcription-id for the transcription ID${NC}" >&2
                else
                    echo "{\"error\": \"Unexpected argument: $1\"}" >&2
                fi
                show_enrich_help
                exit 1
                ;;
        esac
    done
    
    # Check that ID is provided
    if [ -z "$transcription_id" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Transcription ID required${NC}" >&2
        else
            echo "{\"error\": \"Transcription ID required\"}" >&2
        fi
        show_enrich_help
        exit 1
    fi
    
    # Validate LLM model if provided
    if [ -n "$llm_model" ]; then
        case "$llm_model" in
            qwen2.5-7b-instruct|mistral-7b-instruct|phi-3-mini)
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Invalid LLM model: $llm_model${NC}" >&2
                    echo -e "${YELLOW}Valid models: qwen2.5-7b-instruct, mistral-7b-instruct, phi-3-mini${NC}" >&2
                else
                    echo "{\"error\": \"Invalid LLM model: $llm_model\"}" >&2
                fi
                exit 1
                ;;
        esac
    fi
    
    # Read prompts file if provided
    local enrichment_prompts=""
    if [ -n "$prompts_file" ]; then
        if [ ! -f "$prompts_file" ]; then
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}âŒ Prompts file not found: $prompts_file${NC}" >&2
            else
                echo "{\"error\": \"Prompts file not found: $prompts_file\"}" >&2
            fi
            exit 1
        fi
        
        # Check for valid JSON
        if ! command -v jq &> /dev/null; then
            # Without jq, just read the file
            enrichment_prompts=$(cat "$prompts_file")
        else
            # With jq, validate JSON
            if ! jq empty "$prompts_file" 2>/dev/null; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Invalid prompts file (invalid JSON): $prompts_file${NC}" >&2
                else
                    echo "{\"error\": \"Invalid prompts file (invalid JSON): $prompts_file\"}" >&2
                fi
                exit 1
            fi
            enrichment_prompts=$(cat "$prompts_file")
        fi
    fi
    
    # Ask for password if not provided
    if [ -z "$PASSWORD" ]; then
        if [ "$verbose" = "true" ]; then
            echo -n "Password for $USERNAME: "
        fi
        read -s PASSWORD
        if [ "$verbose" = "true" ]; then
            echo ""
        fi
    fi
    
    # Get JWT token
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ” Authenticating...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${API_URL}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${USERNAME}&password=${PASSWORD}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Authentication error${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        exit 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Unable to extract token${NC}" >&2
        fi
        exit 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}âœ“ Authentication successful${NC}" >&2
    fi
    
    # Build JSON body for request
    local json_body="{"
    local first=true
    
    if [ -n "$llm_model" ]; then
        json_body="${json_body}\"llm_model\": \"${llm_model}\""
        first=false
    fi
    
    if [ -n "$text_correction" ]; then
        if [ "$first" = "false" ]; then
            json_body="${json_body}, "
        fi
        json_body="${json_body}\"text_correction\": ${text_correction}"
        first=false
    fi
    
    if [ -n "$enrichment_prompts" ]; then
        if [ "$first" = "false" ]; then
            json_body="${json_body}, "
        fi
        json_body="${json_body}\"enrichment_prompts\": ${enrichment_prompts}"
        first=false
    fi
    
    json_body="${json_body}}"
    
    # Trigger enrichment
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸš€ Triggering enrichment for transcription '${transcription_id}'...${NC}" >&2
    fi
    
    local response=$(curl -s -X POST "${API_URL}/api/user/transcriptions/${transcription_id}/re-enrich" \
        -H "Authorization: Bearer ${token}" \
        -H "Content-Type: application/json" \
        -d "$json_body")
    
    # Check response
    if echo "$response" | grep -q '"task_id"'; then
        local task_id=$(echo "$response" | grep -o '"task_id":"[^"]*' | cut -d'"' -f4)
        
        # If --wait is not enabled, print JSON and exit
        if [ "$wait_for_completion" != "true" ]; then
            # Always print JSON
            if command -v jq &> /dev/null; then
                echo "$response" | jq '.'
            else
                echo "$response"
            fi
            
            # Show verbose messages if requested
            if [ "$verbose" = "true" ]; then
                local status=$(echo "$response" | grep -o '"status":"[^"]*' | cut -d'"' -f4)
                echo "" >&2
                echo -e "${GREEN}âœ“ Enrichment triggered successfully!${NC}" >&2
                echo "Task ID: $task_id" >&2
                echo "Status: $status" >&2
                echo "" >&2
                echo "To follow progress:" >&2
                echo "  $0 --action=status -tid ${transcription_id}" >&2
            fi
        else
            # --wait mode: wait for enrichment completion
            if [ "$verbose" = "true" ]; then
                echo -e "${BLUE}â³ Waiting for enrichment completion...${NC}" >&2
                echo "Transcription ID: $transcription_id" >&2
                echo "Task ID: $task_id" >&2
            fi
            
            # Polling jusqu'Ã  ce que enrichment_status soit "done" ou "error"
            local enrichment_status="pending"
            local max_attempts=3600  # 1 heure max (1 seconde par tentative)
            local attempt=0
            local poll_interval=2  # 2 secondes entre les tentatives
            
            while [ "$enrichment_status" != "done" ] && [ "$enrichment_status" != "error" ] && [ $attempt -lt $max_attempts ]; do
                sleep $poll_interval
                attempt=$((attempt + 1))
                
                local status_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
                
                if [ $? -eq 0 ]; then
                    # Extract enrichment_status from response
                    enrichment_status=$(echo "$status_response" | grep -o '"enrichment_status":"[^"]*' | cut -d'"' -f4)
                    
                    # If enrichment_status is null or empty, enrichment is not present
                    if [ -z "$enrichment_status" ] || [ "$enrichment_status" = "null" ]; then
                        enrichment_status="pending"
                    fi
                    
                    if [ "$verbose" = "true" ]; then
                        # Show progress dot every 5 seconds (approx, depending on attempt % 3)
                        if [ $((attempt % 3)) -eq 0 ]; then
                            echo -e "${BLUE}.${NC}" >&2
                        fi
                    fi
                else
                    if [ "$verbose" = "true" ]; then
                        echo -e "${YELLOW}âš ï¸  Error retrieving status, retrying...${NC}" >&2
                    fi
                fi
            done
            
            if [ "$verbose" = "true" ]; then
                echo "" >&2
            fi
            
            # Retrieve final result
            local final_response=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
            
            if [ $? -eq 0 ]; then
                # Show final result in JSON
                if command -v jq &> /dev/null; then
                    echo "$final_response" | jq '.'
                else
                    echo "$final_response"
                fi
                
                if [ "$verbose" = "true" ]; then
                    local final_enrichment_status=$(echo "$final_response" | grep -o '"enrichment_status":"[^"]*' | cut -d'"' -f4)
                    echo "" >&2
                    if [ "$final_enrichment_status" = "done" ]; then
                        echo -e "${GREEN}âœ“ Enrichment completed successfully!${NC}" >&2
                    elif [ "$final_enrichment_status" = "error" ]; then
                        local error_msg=$(echo "$final_response" | grep -o '"enrichment_error":"[^"]*' | cut -d'"' -f4)
                        echo -e "${RED}âŒ Enrichment failed: ${error_msg}${NC}" >&2
                    fi
                fi
            else
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unable to retrieve final result${NC}" >&2
                else
                    echo "{\"error\": \"Unable to retrieve final result\"}" >&2
                fi
                exit 1
            fi
            
            # Check if attempts limit reached
            if [ $attempt -ge $max_attempts ]; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${YELLOW}âš ï¸  Timeout: enrichment is taking longer than expected${NC}" >&2
                else
                    echo "{\"error\": \"Timeout: enrichment is taking longer than expected\"}" >&2
                fi
                exit 1
            fi
        fi
    else
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Error triggering enrichment${NC}" >&2
            echo "$response" >&2
        else
            echo "$response" >&2
        fi
        exit 1
    fi
}

# Action purge
action_purge() {
    local transcription_id=""
    local project_name=""
    local date_from=""
    local dry_run="false"
    local verbose="false"
    
    # Parse purge arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_purge_help
                exit 0
                ;;
            -tid|--transcription-id)
                transcription_id="$2"
                shift 2
                ;;
            -P|--project)
                project_name="$2"
                shift 2
                ;;
            -d|--date)
                date_from="$2"
                shift 2
                ;;
            --dry-run)
                dry_run="true"
                shift
                ;;
            -v|--verbose)
                verbose="true"
                shift
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            -*)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unknown option: $1${NC}" >&2
                else
                    echo "{\"error\": \"Unknown option: $1\"}" >&2
                fi
                show_purge_help
                exit 1
                ;;
            *)
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ Unexpected argument: $1${NC}" >&2
                else
                    echo "{\"error\": \"Unexpected argument: $1\"}" >&2
                fi
                show_purge_help
                exit 1
                ;;
        esac
    done
    
    # Check that at least one criterion is provided
    if [ -z "$transcription_id" ] && [ -z "$project_name" ] && [ -z "$date_from" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ At least one criterion required (transcription-id, project or date)${NC}" >&2
        else
            echo "{\"error\": \"At least one criterion required (transcription-id, project or date)\"}" >&2
        fi
        show_purge_help
        exit 1
    fi
    
    # Ask for password if not provided
    if [ -z "$PASSWORD" ]; then
        if [ "$verbose" = "true" ]; then
            echo -n "Password for $USERNAME: "
        fi
        read -s PASSWORD
        if [ "$verbose" = "true" ]; then
            echo ""
        fi
    fi
    
    # Get JWT token
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ” Authenticating...${NC}" >&2
    fi
    local token_response=$(curl -s -X POST "${API_URL}/api/auth/token" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "username=${USERNAME}&password=${PASSWORD}")
    
    if ! echo "$token_response" | grep -q "access_token"; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Authentication error${NC}" >&2
            echo "$token_response" >&2
        else
            echo "$token_response" >&2
        fi
        exit 1
    fi
    
    local token=$(echo "$token_response" | grep -o '"access_token":"[^"]*' | cut -d'"' -f4)
    
    if [ -z "$token" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Unable to extract token${NC}" >&2
        fi
        exit 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}âœ“ Authentication successful${NC}" >&2
    fi
    
    # Collect IDs of transcriptions to delete
    local transcription_ids=()
    local project_for_api_key=""
    
    # If specific ID is provided
    if [ -n "$transcription_id" ]; then
        transcription_ids+=("$transcription_id")
        # Retrieve project for this transcription to get API key
        if [ "$verbose" = "true" ]; then
            echo -e "${BLUE}ðŸ” Retrieving transcription info...${NC}" >&2
        fi
        local trans_info=$(get_transcription_status "$transcription_id" "$token" "$API_URL")
        if [ $? -eq 0 ]; then
            project_for_api_key=$(echo "$trans_info" | grep -o '"project_name":"[^"]*' | cut -d'"' -f4)
        else
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}âŒ Unable to retrieve transcription${NC}" >&2
            else
                echo "{\"error\": \"Unable to retrieve transcription: ${transcription_id}\"}" >&2
            fi
            exit 1
        fi
    else
        # List transcriptions based on criteria
        if [ "$verbose" = "true" ]; then
            echo -e "${BLUE}ðŸ” Searching transcriptions to delete...${NC}" >&2
        fi
        
        # Build list URL with filters
        # Note: API limits limit to 100 maximum
        local list_url="${API_URL}/api/user/transcriptions?limit=100"
        if [ -n "$project_name" ]; then
            list_url="${list_url}&project=${project_name}"
        fi
        
        # Retrieve all transcriptions (with pagination if needed)
        local page=1
        
        while true; do
            local page_url="${list_url}&page=${page}"
            local response=$(curl -s -X GET "$page_url" \
                -H "Authorization: Bearer ${token}")
            
            # Check if response contains an error
            if echo "$response" | grep -q '"detail"'; then
                if [ "$verbose" = "true" ]; then
                    echo -e "${RED}âŒ API Error:${NC}" >&2
                    echo "$response" | jq '.' >&2 2>/dev/null || echo "$response" >&2
                else
                    echo "$response" >&2
                fi
                exit 1
            fi
            
            # Check if response is a valid JSON array
            if ! echo "$response" | grep -q '^\['; then
                break
            fi
            
            # Check if array is empty
            if command -v jq &> /dev/null; then
                local array_length=$(echo "$response" | jq 'length' 2>/dev/null || echo "0")
                if [ "$array_length" -eq 0 ]; then
                    break
                fi
            fi
            
            # Extract IDs and dates of transcriptions
            # Use jq if available to parse JSON, otherwise use grep
            if command -v jq &> /dev/null; then
                # With jq, we can extract IDs and dates easily
                local page_data=$(echo "$response" | jq -r '.[] | "\(.id)|\(.created_at)"')
                
                if [ -z "$page_data" ]; then
                    break
                fi
                
                # Convert reference date to timestamp if needed
                local date_timestamp=""
                if [ -n "$date_from" ]; then
                    date_timestamp=$(date -d "$date_from" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$date_from" +%s 2>/dev/null || echo "")
                    if [ -z "$date_timestamp" ]; then
                        # Try ISO format
                        date_timestamp=$(date -d "$date_from" +%s 2>/dev/null || echo "")
                    fi
                    if [ -z "$date_timestamp" ]; then
                        if [ "$verbose" = "true" ]; then
                            echo -e "${RED}âŒ Invalid date format: $date_from${NC}" >&2
                        else
                            echo "{\"error\": \"Invalid date format: $date_from\"}" >&2
                        fi
                        exit 1
                    fi
                fi
                
                # Process each transcription
                while IFS='|' read -r tid created_at; do
                    if [ -n "$tid" ]; then
                        # Filter by date if needed
                        if [ -n "$date_from" ] && [ -n "$date_timestamp" ]; then
                            local trans_timestamp=$(date -d "$created_at" +%s 2>/dev/null || echo "")
                            if [ -n "$trans_timestamp" ] && [ "$trans_timestamp" -ge "$date_timestamp" ]; then
                                transcription_ids+=("$tid")
                            fi
                        else
                            transcription_ids+=("$tid")
                        fi
                    fi
                done <<< "$page_data"
            else
                # Without jq, use grep (less precise but works)
                local page_ids=$(echo "$response" | grep -o '"id":"[^"]*' | cut -d'"' -f4)
                
                if [ -z "$page_ids" ]; then
                    break
                fi
                
                # If no date filter, add all IDs
                if [ -z "$date_from" ]; then
                    for tid in $page_ids; do
                        transcription_ids+=("$tid")
                    done
                else
                    # With date filter, we must retrieve each transcription to check the date
                    for tid in $page_ids; do
                        local trans_response=$(get_transcription_status "$tid" "$token" "$API_URL")
                        if [ $? -eq 0 ]; then
                            local created_at=$(echo "$trans_response" | grep -o '"created_at":"[^"]*' | cut -d'"' -f4)
                            if [ -n "$created_at" ]; then
                                local date_timestamp=$(date -d "$date_from" +%s 2>/dev/null || date -j -f "%Y-%m-%d" "$date_from" +%s 2>/dev/null || echo "")
                                if [ -z "$date_timestamp" ]; then
                                    date_timestamp=$(date -d "$date_from" +%s 2>/dev/null || echo "")
                                fi
                                if [ -n "$date_timestamp" ]; then
                                    local trans_timestamp=$(date -d "$created_at" +%s 2>/dev/null || echo "")
                                    if [ -n "$trans_timestamp" ] && [ "$trans_timestamp" -ge "$date_timestamp" ]; then
                                        transcription_ids+=("$tid")
                                    fi
                                fi
                            fi
                        fi
                    done
                fi
            fi
            
            # Check if there are more pages (limit of 100 per page)
            local count=0
            if command -v jq &> /dev/null; then
                count=$(echo "$response" | jq 'length' 2>/dev/null || echo "0")
            else
                count=$(echo "$page_ids" | wc -l)
            fi
            
            if [ "$count" -lt 100 ]; then
                break
            fi
            page=$((page + 1))
        done
        
        # If a project is specified, use it for API key
        if [ -n "$project_name" ]; then
            project_for_api_key="$project_name"
        else
            # If no project specified but transcriptions found, use the project of the first one
            if [ ${#transcription_ids[@]} -gt 0 ]; then
                local first_id="${transcription_ids[0]}"
                local first_trans=$(get_transcription_status "$first_id" "$token" "$API_URL")
                if [ $? -eq 0 ]; then
                    project_for_api_key=$(echo "$first_trans" | grep -o '"project_name":"[^"]*' | cut -d'"' -f4)
                fi
            fi
        fi
    fi
    
    # Retrieve internal key (required for DELETE endpoint)
    # The internal key is a server config, it must be provided in ~/.vocalyx_config
    # It corresponds to INTERNAL_API_KEY in docker-compose.yml or config.ini
    local internal_key="${INTERNAL_API_KEY:-${VOCALYX_INTERNAL_KEY:-}}"
    
    if [ -z "$internal_key" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${RED}âŒ Internal key required for deletion${NC}" >&2
            echo -e "${YELLOW}   DELETE endpoint requires X-Internal-Key${NC}" >&2
            echo -e "${YELLOW}   Define INTERNAL_API_KEY or VOCALYX_INTERNAL_KEY in ~/.vocalyx_config${NC}" >&2
            echo -e "${YELLOW}   Example: INTERNAL_API_KEY=secret_key_for_internal_comms_123456${NC}" >&2
        else
            echo "{\"error\": \"Internal key required for deletion. Define INTERNAL_API_KEY or VOCALYX_INTERNAL_KEY in your configuration\"}" >&2
        fi
        exit 1
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${GREEN}âœ“ Internal key found${NC}" >&2
    fi
    
    # Show number of transcriptions to delete
    local count=${#transcription_ids[@]}
    
    if [ "$count" -eq 0 ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${YELLOW}â„¹ï¸  No transcription found to delete${NC}" >&2
        else
            echo "{\"count\": 0, \"message\": \"No transcription found to delete\"}"
        fi
        exit 0
    fi
    
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ“‹ ${count} transcription(s) found${NC}" >&2
    fi
    
    # Dry-run mode: show without deleting
    if [ "$dry_run" = "true" ]; then
        if [ "$verbose" = "true" ]; then
            echo -e "${YELLOW}ðŸ” Dry-run mode: showing transcriptions that would be deleted${NC}" >&2
        fi
        
        local result_json="{\"dry_run\": true, \"count\": ${count}, \"transcription_ids\": ["
        local first=true
        for tid in "${transcription_ids[@]}"; do
            if [ "$first" = "false" ]; then
                result_json="${result_json}, "
            fi
            result_json="${result_json}\"${tid}\""
            first=false
        done
        result_json="${result_json}]}"
        
        if command -v jq &> /dev/null; then
            echo "$result_json" | jq '.'
        else
            echo "$result_json"
        fi
        
        if [ "$verbose" = "true" ]; then
            echo "" >&2
            echo "IDs of transcriptions that would be deleted:" >&2
            for tid in "${transcription_ids[@]}"; do
                echo "  - $tid" >&2
            done
        fi
        exit 0
    fi
    
    # Delete transcriptions
    if [ "$verbose" = "true" ]; then
        echo -e "${BLUE}ðŸ—‘ï¸  Deleting ${count} transcription(s)...${NC}" >&2
    fi
    
    local deleted_count=0
    local failed_count=0
    local deleted_ids=()
    local failed_ids=()
    
    for tid in "${transcription_ids[@]}"; do
        # Use internal key (DELETE endpoint requires X-Internal-Key)
        local delete_response
        delete_response=$(curl -s -X DELETE "${API_URL}/api/transcriptions/${tid}" \
            -H "X-Internal-Key: ${internal_key}")
        
        # Check if deletion succeeded
        if echo "$delete_response" | grep -q '"status":"deleted"'; then
            deleted_count=$((deleted_count + 1))
            deleted_ids+=("$tid")
            if [ "$verbose" = "true" ]; then
                echo -e "${GREEN}âœ“ Deleted: ${tid}${NC}" >&2
            fi
        else
            failed_count=$((failed_count + 1))
            failed_ids+=("$tid")
            if [ "$verbose" = "true" ]; then
                echo -e "${RED}âŒ Failed: ${tid}${NC}" >&2
                echo "$delete_response" >&2
            fi
        fi
    done
    
    # Show result
    local result_json="{\"deleted\": ${deleted_count}, \"failed\": ${failed_count}, \"total\": ${count}}"
    
    if command -v jq &> /dev/null; then
        echo "$result_json" | jq '.'
    else
        echo "$result_json"
    fi
    
    if [ "$verbose" = "true" ]; then
        echo "" >&2
        echo -e "${GREEN}âœ“ ${deleted_count} transcription(s) deleted${NC}" >&2
        if [ "$failed_count" -gt 0 ]; then
            echo -e "${RED}âŒ ${failed_count} failures${NC}" >&2
        fi
    fi
    
    if [ "$failed_count" -gt 0 ]; then
        exit 1
    fi
}

# Main function
main() {
    # Configuration is already loaded at the beginning of the script
    # load_config() can be used to reload if necessary
    
    # Variables for global options
    local action=""
    
    # Parse global arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --action=*)
                action="${1#*=}"
                shift
                ;;
            --action)
                action="$2"
                shift 2
                ;;
            -h|--help)
                # If action is already defined, let --help pass to the action
                if [ -n "$action" ]; then
                    break
                fi
                show_help
                exit 0
                ;;
            -u|--username)
                USERNAME="$2"
                shift 2
                ;;
            -p|--password)
                PASSWORD="$2"
                shift 2
                ;;
            -a|--api-url)
                API_URL="$2"
                shift 2
                ;;
            *)
                # If no action is defined, show help
                if [ -z "$action" ]; then
                    echo -e "${RED}âŒ Action required. Use --action=<action>${NC}" >&2
                    echo ""
                    show_help
                    exit 1
                fi
                # Pass remaining arguments to action
                break
                ;;
        esac
    done
    
    # Check that action is specified
    if [ -z "$action" ]; then
        echo -e "${RED}âŒ Action required. Use --action=<action>${NC}" >&2
        echo ""
        show_help
        exit 1
    fi
    
    # Execute appropriate action
    case "$action" in
        transcribe)
            action_transcribe "$@"
            ;;
        status)
            action_status "$@"
            ;;
        enrich)
            action_enrich "$@"
            ;;
        purge)
            action_purge "$@"
            ;;
        *)
            echo -e "${RED}âŒ Unknown action: $action${NC}" >&2
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Execute main function
main "$@"

