name: CI - Integration Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

jobs:
  docker-integration-test:
    name: Docker Integration Test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file for testing
        run: |
          # Créer un fichier .env de test à partir de .env.example
          if [ -f .env.example ]; then
            cp .env.example .env
            echo "✅ Fichier .env créé"
          else
            echo "⚠️  .env.example non trouvé, création d'un .env minimal"
            cat > .env << EOF
          # Configuration de test
          POSTGRES_PASSWORD=test_password
          INTERNAL_API_KEY=test_internal_key
          EOF
          fi

      - name: Create required directories
        run: |
          mkdir -p shared/logs shared/uploads shared/models shared/backups
          echo "✅ Répertoires créés"

      - name: Start services
        run: |
          docker compose up -d
          echo "✅ Services démarrés"

      - name: Wait for services to be healthy
        run: |
          echo "Attente du démarrage des services..."
          sleep 30
          
          # Attendre que PostgreSQL soit prêt
          timeout 60 bash -c 'until docker compose exec -T postgres pg_isready -U vocalyx -d vocalyx_db; do sleep 2; done'
          echo "✅ PostgreSQL est prêt"
          
          # Attendre que Redis soit prêt
          timeout 30 bash -c 'until docker compose exec -T redis redis-cli ping; do sleep 2; done'
          echo "✅ Redis est prêt"
          
          # Attendre que l'API soit prête
          timeout 60 bash -c 'until curl -f http://localhost:8000/health 2>/dev/null; do sleep 3; done'
          echo "✅ API est prête"

      - name: Check API health endpoint
        run: |
          response=$(curl -s http://localhost:8000/health || echo "FAIL")
          if [ "$response" = "FAIL" ]; then
            echo "❌ L'endpoint /health n'est pas accessible"
            docker compose logs vocalyx-api-01
            exit 1
          fi
          echo "✅ API health check réussi"
          echo "$response"

      - name: Check API docs endpoint
        run: |
          status=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/docs || echo "000")
          if [ "$status" != "200" ]; then
            echo "⚠️  L'endpoint /docs retourne le code $status"
          else
            echo "✅ API docs accessible"
          fi

      - name: Test database connection
        run: |
          docker compose exec -T postgres psql -U vocalyx -d vocalyx_db -c "SELECT version();" || exit 1
          echo "✅ Connexion à la base de données réussie"

      - name: Check services status
        run: |
          docker compose ps
          echo "✅ Statut des services affiché"

      - name: Collect logs on failure
        if: failure()
        run: |
          echo "=== Logs API ==="
          docker compose logs vocalyx-api-01 || true
          echo ""
          echo "=== Logs Frontend ==="
          docker compose logs vocalyx-frontend || true
          echo ""
          echo "=== Logs Postgres ==="
          docker compose logs postgres || true

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v
          echo "✅ Nettoyage terminé"
